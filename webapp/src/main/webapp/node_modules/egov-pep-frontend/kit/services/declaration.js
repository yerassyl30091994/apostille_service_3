angular.module("app").service('$declaration', ['$http', '$q', '$rootScope', '$session', '$robot', '$sound', '$timeout',
    '$state', '$injector', '$interval', '$eds', '$error', '$settings',
    function ($http, $q, $rootScope, $session, $robot, $sound, $timeout, $state, $injector, $interval, $eds, $error,
              $settings) {

        var self = this;

        var appId = null;

        this.requestId = null;
        this.state = null;
        this.model = {};
        this.isEmpty = isEmpty;/*Проверяет пустой символ, undefined, null, если одно из этих значений верно, то возвращает тру*/
        this.totalSteps = null;
        this.vote = {
            voteState: 'DENIED',
            comment: ''
        };

        $rootScope.$declaration = this;

        this.UI = function () {
            return $settings.getClientType();
        };

        function isEmpty(val) {
          if (val === '' || typeof val === "undefined" || val === null) {
            return true;
          } else {
            return false;
          }
        }

        this.askVoteState = function () {
        /*
            if (self.requestId && self.state && self.state.recipientUin) {
                $http.get('rest/like/' + self.requestId + '/' + self.state.declarantIdentificationNumber).then(function (response) {
                    self.vote.voteState = response.data.voteState;
                }, function (response) {
                    console.error('rest/like/' + self.requestId + '/' + self.state.declarantIdentificationNumber + ' вернул ошибку');
                    console.error(response);
                });
            }
        */
            if (self.requestId && (($settings.isPep() && !!$session && !!$session.uin) || $settings.isPod())) {
                var uin = $settings.isPep() ? $session.uin : self.state.declarantIdentificationNumber;
                $http.get('rest/like/' + self.requestId + '/' + uin).then(function (response) {
                    self.vote.voteState = response.data.voteState;
                }, function (response) {
                    console.error('rest/like/' + self.requestId + '/' + uin + ' вернул ошибку');
                    console.error(response);
                });
            }
        };

        this.getCurrentState = function () {
            var defer = $q.defer();
            if (self.requestId == null) {
                defer.reject();
            } else {
                $http.get('rest/request-states/' + self.requestId).then(function (rs) {
                    self.state = rs.data;
                    self.askVoteState();
                    defer.resolve(self.state);
                }, function () {
                    // OP - закоментировал обнуление state т.к. на поде из-за этого статусная страница полностью очищается и работа с услугой парализуется
                    // self.state = null;
                    $error.setError("declaration.error.load");
                    defer.resolve(self.state);
                });
            }
            return defer.promise;
        };

        this.loadRequest = function (_requestId) {
            if (_requestId) {
                $http.get('rest/request-states/' + _requestId).then(function (rs) {
                    if (rs.status == 200) {
                        self.requestId = _requestId;
                        self.state = rs.data;
                        self.goStep('status');
                        self.askVoteState();
                    }
                }, function () {
                    $error.setError("declaration.error.load");
                });
            }
        };

        this.haveGroupAgreement = function () {
            return self.model.groupAgreement;
        };

        this.path = function () {
            return null;
        };

        var decodeModel = function (code) {

            var seq = code.split(',');
            function rec(obj) {
                _.each(_.keys(obj), function (key) {

                    function read(type, convert) {
                        var persistanceInfoRef = '__persistant' + type;
                        if (obj[persistanceInfoRef] && _.contains(obj[persistanceInfoRef], key)) {
                            obj[key] = decodeURIComponent(seq[0]);
                            seq = seq.slice(1);
                        }
                    }

                    if (_.isObject(obj[key])) {
                        rec(obj[key]);
                    }
                });
            }
            rec(self.model);
        };

        var encodeModel = function () {

            var result = [];
            function rec(obj) {
                _.each(_.keys(obj), function (key) {

                    if (obj.__persistant && _.contains(obj.__persistant, key)) {
                        result.push(encodeURIComponent(obj[key]));
                    }

                    if (_.isObject(obj[key])) {
                        rec(obj[key]);
                    }
                });
            }
            rec(self.model);
            return result.join(',');

        };

        var parseAnnotatedModel = function (annotatedModel) {

            var result = _.cloneDeep(annotatedModel);

            function rec(obj) {
                _.each(_.keys(obj), function (key) {

                    if (key.indexOf('@') == 0) {
                        if (key.length == 1) throw 'Имя сохраняемого свойства не указано';
                        if (!(_.isString(obj[key]) || _.isNumber(obj[key]) || _.isBoolean(obj[key]))) throw 'Сохраняемое свойство ' + key + ' должно быть примитивом';

                        var prop = key.substr(1);
                        obj[prop] = obj[key];

                        obj.__persistant = obj.__persistant || [];
                        obj.__persistant.push(prop);
                        delete obj[key];
                    }

                    if (_.isObject(obj[key])) {
                        rec(obj[key]);
                    }
                });
            }

            rec(result);

            return result;
        };

        var annotatedInitialModel = null;
        var initialModel = null;
        var readyState = {
            isInitialized: false,
            isLoaded: false
        };
        this.init = function (_appId, _annotatedInitialModel) {

            readyState.isInitialized = false;

            appId = _appId;
            annotatedInitialModel = _.cloneDeep(_annotatedInitialModel);
            initialModel = parseAnnotatedModel(_annotatedInitialModel);
            self.reset();

            if ($state.params.model) {
                decodeModel($state.params.model);
            }

            $state.params.requestId = $state.params.requestId || window.__contextParams.params['request-number'];

            if ($state.params.requestId) {
                self.loadRequest($state.params.requestId);
            }

            if ($state.params.step) {
                var step = self.getStepByIndex($state.params.step);
                this.goStep(step);
            }

            var $router = $injector.get('$router');
            $router.afterLoading(function () {
                readyState.isInitialized = true;
                tryLoadStep($state.params.step && $state.params.step != "" ? $state.params.step : 0);
                watchModelChangesAndResetSteps();
                self.playSound();
            });
        };

        this.extend = function (annotatedModelExtension) {

            var extendedAnnotatedInitialModel = {};
            $.extend(true, extendedAnnotatedInitialModel, annotatedInitialModel, annotatedModelExtension);
            self.init(appId, extendedAnnotatedInitialModel);
        };

        this.onStepsRegistered = function () {

            var sortedSteps = _.sortBy(_.values(steps), function (step) {
                return step.index;
            });
            steps = _.zipObject(_.pluck(sortedSteps, 'id'), sortedSteps);

            var $router = $injector.get('$router');
            $router.afterLoading(function () {
                readyState.isLoaded = true;
                whenLoaded();
            });
        };


        this.isReady = function () {
            return readyState.isLoaded && readyState.isInitialized;
        };

        var onLoadedCallbacks = [];
        this.onLoaded = function (onLoaded) {
            onLoadedCallbacks.push(onLoaded);
            if (readyState.isLoaded) {
                whenLoaded();
            }
        };

        function whenLoaded() {
            _.each(_.cloneDeep(onLoadedCallbacks), function (callback, index) {
                callback();
                delete onLoadedCallbacks[index];
            });
        }


        this.persist = function () {
            var router = $injector.get('$router');
            $state.transitionTo(router.getActiveLocation().get().code, { step: currentStepObj.index, model: encodeModel(), requestId: self.requestId });
            var href = $state.href(router.getActiveLocation().get().code, { step: currentStepObj.index, model: encodeModel(), requestId: self.requestId });
            location.hash = href;
        };

        this.playSound = function () {
            $timeout(function () {
                $sound.play('info');
            }, 500);
            $robot.slightlyOpenedEyes();
        };

        this.reset = function () {
            if (!initialModel) return;
            self.model = _.cloneDeep(initialModel);
            self.state = null;
            self.requestId = null;
            $rootScope.resetInputs && $rootScope.resetInputs();


            if (!currentStepObj || currentStepObj.index != 0) {
                this.goStep(this.getStepByIndex(0));
            }
        };

        this.stepName = function (stepId) {
            return 'config.apps.' + appId + '.steps.' + stepId;
        };

        /// Содержит в себе объекты всех шагов, найденных на странице.
        /// Каждая директива [sign] на странице самостоятельно дополняет этот объект при инициализации
        var steps = {};

        var startPosition = 0;
        this.maxSteps = 4;

        /// Объект текущего шага
        var currentStepObj = null;

        /// Объект предыдущего шага. Перезаписывается при вызове метода goStep(). Может быть null
        var prevStepObj = null;

        this.currentStep = function () {
            // if (!currentStepObj){
            //   currentStepObj = _.values(steps)[0];  
            // } 
            return currentStepObj;
        };

        this.getStepByIndex = function (index) {
            return _.find(steps, function (step) {
                return step.index == index;
            });
        };

        /// Переходит на указанный шаг. В параметры можно передавать как объект шага так и его ИД
        this.goStep = function (stepObjOrStepId) {
            var stepId;

            if (_.isString(stepObjOrStepId))
                stepId = stepObjOrStepId;
            else
                stepId = stepObjOrStepId.id;

            if (!steps[stepId]) return;
            if (steps[stepId] == currentStepObj) return;
            if (steps[stepId].index <= startPosition) {
                startPosition = steps[stepId].index;
            } else {
                if (steps[stepId].index >= startPosition + self.maxSteps) {
                    startPosition = steps[stepId].index - self.maxSteps + 1;
                }
            }
            steps[stepId].consistent = true;
            prevStepObj = currentStepObj;
            currentStepObj = steps[stepId];
            self.persist();
            fireStepActivationListeners();
        };

        this.goStepByIndex = function (index) {
            self.goStep(self.getStepByIndex(index).id);
        };

        /// Возвращает на предыдущий шаг, согласно истории шагов
        this.goPrevStep = function () {
            if (!prevStepObj) return;
            self.goStep(prevStepObj.id);
        };

        this.getCurrentPosition = function () {
            return startPosition;
        };

        this.registerStep = function (step) {
            if (steps[step.id]) return;
            step.consistent = false;
            steps[step.id] = step;

            if (self.totalSteps && self.totalSteps == _.keys(steps).length) {
                this.onStepsRegistered();
            }
        };

        function tryLoadStep(index) {
            var step = _.find(steps, function (step) {
                return step.index == index;
            });
            if (!step) step = steps[0];
            if (!self.isStepAllowed(step)) {
                step = null;
                for (var i = 0; i < self.totalSteps; i++) {
                    if (self.isStepAllowed(self.getStepByIndex(i))) {
                        step = self.getStepByIndex(i);
                        break;
                    }
                }
                if (!step) {
                    step = self.getStepByIndex(0);
                }
            }
            for (i = 0; i <= step.index; i++) {
                self.getStepByIndex(i).consistent = true;
            }
            self.goStep(step.id);
        }

        this.getSteps = function () {
            return _.values(steps);
        };

        this.showStepRequired = function (step) {
            if (self.totalSteps <= self.maxSteps) {
                return true;
            }
            // Ограничение в maxSteps шагов на странице
            return step >= startPosition && step < startPosition + self.maxSteps;
        };

        this.nextSteps = function () {
            if (startPosition + self.maxSteps < self.totalSteps) {
                startPosition++;
            }
        };

        this.previousSteps = function () {
            if (startPosition > 0) {
                startPosition--;
            }
        };

        var stepAllowPredicates = {};
        this.isStepAvailable = function (step) {
            if (!self.isReady()) return false;
            if (_.isString(step)) step = steps[step];
            return step.consistent && self.isStepAllowed(step);
        };
        this.isStepAllowed = function (step) {
            if (!self.isReady()) return false;
            if (_.isString(step)) step = steps[step];
            return stepAllowPredicates[step.id] && stepAllowPredicates[step.id]() || !stepAllowPredicates[step.id];
        };
        this.allowStep = function (stepId, predicate) {
            stepAllowPredicates[stepId] = predicate;
        };

        var stepActivationListeners = {};
        this.onStep = function (stepId, listener) {
            stepActivationListeners[stepId] = stepActivationListeners[stepId] || [];
            stepActivationListeners[stepId].push(listener);
        };
        function fireStepActivationListeners() {
            if (!stepActivationListeners[currentStepObj.id]) return;
            _.each(stepActivationListeners[currentStepObj.id], function (listener) { listener(); });
        }

        //если для текущего шага поменялась модель, пометить все следующие шаги как непосещенные
        function watchModelChangesAndResetSteps() {
            var _visitsWasResetForStep = -1;//небольшая оптимизация чтобы не дергать сброс visited на каждый апдейт модели
            $rootScope.$watch('$declaration.model', function () {
                self.persist();

                if (_visitsWasResetForStep != currentStepObj.index) {//
                    for (var stepIndex = currentStepObj.index + 1; stepIndex < _.keys(steps).length; stepIndex++) {
                        self.getStepByIndex(stepIndex).consistent = false;
                    }
                    _visitsWasResetForStep = currentStepObj.index;
                }
            }, true);
        }

        this.getEstimate = function () {
            return this.getConfig().estimate;
        };

        this.onSignError = function (error, errorMessageI18nToken) {

            $robot.connectionError();

            if (errorMessageI18nToken) {
                $error.setError(errorMessageI18nToken);
            } else {
                $error.setError("signable.serverError");
            }
            if (error) {
                console.error(error);
            }

            self.goPrevStep();
        };

        this.getUrlParam = function () {
            return window.__contextParams.params;
        };

        this.signByIndividual = function (processCert) {
            $eds.open('sign', {
                filter: ['fl'],
                onCert: function (cert) {
                    if (!$session.uin) {
                        /*Если человек не авторизован, то ИИН заявителя берется из сертификата*/
                        self.model.data.declarantUin = cert.uin;
                        onDeclarantSet();
                    } else if ($session.operator) {
                        /*Если заявку получает оператор и подписывает своей подписью за заявителя, то ИИН заявителя отправляют на rest/current-user/change-declarant-iin-bin */
                        if(!self.model.data.declarantUin) {
                            self.model.data.declarantUin = $session.uin;
                        }
                        $session.changeDeclarant(self.model.data.declarantUin).then(onDeclarantSet);
                    } else {
                        console.log("signByIndividual");
                        if (!self.model.data.declarantUin) {
                            self.model.data.declarantUin = $session.uin;
                        }
                        onDeclarantSet();
                        // /*Если человек авторизован, и подписывает не своей подписью, то выводим сообщение что нужно использовать ЭЦП аутентифицированного пользователя*/
                        // if (!self.model.data.declarantUin) {
                        //     self.model.data.declarantUin = $session.uin;
                        // }
                        // /*Переменная NO_MATCH_UIN находится в static-resources, если static-resources не доступен то проверка cert.uin c uin заявителем осуществляется,
                        // если static-resources доступен, то определяется переменной NO_MATCH_UIN.
                        // Если NO_MATCH_UIN: true - нет проверки UIN ЭЦП с UIN заявителем, false - есть проверка UIN ЭЦП с UIN заявителем*/
                        // if (!(typeof EDS_CONFIG != 'undefined' && EDS_CONFIG.NO_MATCH_UIN) && cert.uin !== self.model.data.declarantUin) {
                        //     return $error.setError("invalidUserID");
                        // }else{
                        //     onDeclarantSet();
                        // }
                    }

                    function onDeclarantSet() {
                        processCert().then(function () {
                            $http.post("rest/app/xml", self.model.data).then(function (rs) {
                                $eds.apply('sign', rs.data.xml);
                            },
                                self.onSignError
                            );
                        });
                    }
                },

                onSign: function (signedXml) {
                    $http.post("rest/app/send-eds" + "?captchaCode=" + $rootScope.captchaCode, { xml: signedXml })
                        .success(function (data) {
                            self.requestId = data.requestNumber;
                            self.goStep('status');
                            console.log("Заявка принята");
                        }).error(function (rs) {
                            self.onSignError(rs);
                        });
                },

                onCancel: function () {
                    self.goStep('search');
                },

                onError: function () {
                    console.error('APPLET REPORTED: SIGNING FAILED');
                }
            });
        };
        this.signForBank = function (processCert) {
            $eds.open('sign2', {
                filter: ['fl'],
                onCert: function (cert) {
                    if (!self.model.data.declarantUin) {
                        self.model.data.declarantUin = $session.uin;
                    }

                    onDeclarantSet();

                    function onDeclarantSet() {
                        processCert().then(function () {
                            $http.post("rest/payment/iban/xml", self.model.data.iban).then(function (rs) {
                                $eds.apply('sign2', rs.data.xml);
                            },
                                function () { $error.setError("Ошибка подписания"); }
                            );
                        });
                    }
                },
                onSign: function (signedXml) {
                    $http.post("rest/payment/iban/account", { bankCode: self.model.data.bank, signedXml: signedXml })
                        .success(function (data) {
                            if(data.status === "SYSTEM_UNAVAILABLE"){ // Система недоступена. Пожалуйста, попробуйте отправить Ваш запрос позднее
                                $error.setError("SYSTEM_UNAVAILABLE");
                            }else if(data.status === "TECH_ERROR"){ // Во время обработки запроса произошла техническая ошибка. Пожалуйста, попробуйте отправить Ваш запрос позднее
                                $error.setError("TECH_ERROR");
                            }else if(data.status === "ACCOUNT_BLOCKED"){ // Счет заблокирован
                                $error.setError("ACCOUNT_BLOCKED");
                            }else if(data.status === "ACCOUNT_CLOSED"){ // Счет закрыт
                                $error.setError("ACCOUNT_CLOSED");
                            }else if(data.status === "ACCOUNT_LIQUIDATED"){ // Счет ликвидирован
                                $error.setError("ACCOUNT_LIQUIDATED");
                            }else if(data.status === "ACCOUNT_UNAVAILABLE"){ // Не существует (данное физическое лицо отсутствует в списке клиентов банка, либо есть клиент, но счета нет)
                                $error.setError("ACCOUNT_UNAVAILABLE");
                            }else if(data.status === "EDS_PROBLEM"){ // Данные запроса не соответствуют данным в подписи
                                $error.setError("EDS_PROBLEM");
                            }else if(data.status === "WRONG_ACCOUNT_TYPE"){ // Не соответствующий тип счета
                                $error.setError("WRONG_ACCOUNT_TYPE");
                            }else if(data.status === "0"){
                                self.model.billApproveStatus = data.status;
                                delete data.status;
                                self.model.data.infoAccount = data;
                                self.model.billApproveSignedXml = signedXml;
                                self.requestId = data.requestNumber;
                                //self.goStep('infochild');
                                console.log("Данные о счете подтверждены");
                            }else{
                                $error.setError("error");
                            }
                        }).error(function (rs) {
                            self.onSignError(rs);
                        });
                },
                onCancel: function () {
                    self.goStep('search');
                }
            });
        };

        this.refreshIsAllowed = function () {
            var status = this.state.status;
            return (status == 'SENDING') || (status == 'IN_PROCESSING') || (status == 'PREPARING_REQUEST') || (status == 'CREATED') ||
                   (status == 'ACCEPTED') || (status == 'WAITING_FOR_APPROVAL') || (status == 'WAITING_FOR_PAYMENT') ||
                   (status == 'PAID') || (status == 'AGREED') || (status == 'GO_TO_PAYMENT_STEP') ||
                   (status == 'WAITING_FOR_MOBILE_SIGNING') || (status == 'IN_QUEUE') || (status == 'NOT_PAID');
        };
        this.restartIsAllowed = function () {
            var status = this.state.status;
            return (status != 'SENDING') && (status != 'IN_PROCESSING') && (status != 'PREPARING_REQUEST') && (status != 'CREATED') &&
                   (status != 'ACCEPTED') && (status != 'WAITING_FOR_APPROVAL') && (status != 'AGREED') && (status != 'IN_QUEUE') &&
                   (status != 'NOT_PAID');
        };

        return _.bindAll(this);
    }]);