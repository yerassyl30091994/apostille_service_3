app.service('$mockService', ['$window', function ($window) {

    // Обычно URL ограничен длиной в 2000 символов
    // Пример сценария объявленного в URL: http://local.nitec.kz:3000/P3.15/?mock&scenario=SM(0,FL_1,FL_2,FL_3)+CM(FL_2)
    // Пример активации сценария по Id: http://local.nitec.kz:3000/P3.15/?mock&scenarioId=MyScenario

    // == Как работает ScenarioBuilder
    // Задача ScenarioBuilder - сделать моки описанные в сценарии - активными
    // ScenarioBuilder создается только если в мок сервисе есть объект Scenario.
    // В каких случаях его может не быть? - в тех, когда в URL указывается Id активного сценария, а сам сценарий регистрируется в мок системе в блоке RUN какой-нибудь услуги.
    // На момент создания ScenarioBuilder он проверяет наличие MockResponse, необходимых для построения моков сценария. Если какие-то моки уже можно сбилдить - они билдятся и становятся активными.
    // Остальные ожидают появления необходимых MockResponse и строятся при первой возможности.
    // Когда приходит время делать первый http запрос к рестам, начинается проверка целостности моков сценария. Если какой-то мок не был построен из-за отсутствия необходимого MockResponse, то об этом напишут в консоли.


    // TODO: хранить базу моков так же как и Response для того чтобы юзать бизнес моки в анонимных сценариях
    // TODO: модификация MockResponse в рантайме
    // TODO: выноска MockResponses услуги в json файл и подгрузка его в run блоке услуги
    // TODO: активация сгенерированного сценария без пересборки, через local-storage
    // TODO: ЗАВИСИМ от contextParams & context
    // TODO: В консоль не выводится сам запрос и его RESPONSE

    var UrlConditions = {
        STARTS_WITH: 'STARTS_WITH',
        CONTAINS: 'CONTAINS',
        EQUAL: 'EQUAL'
    }

    // ===========================================================================================
    // === КЛАССЫ ================================================================================
    // ===========================================================================================

    function MockResponse(id, method, url, urlCondition, status, data, headers, redirect) {

        function mockResponseonstructor() {
            // TODO: validate id is without special chars
            if (!id) throw new Error('MockResponse constructor: id is null or undefined');
            if (!method) throw new Error('MockResponse constructor: method is null or undefined. RepsponseId=' + id);
            if (!url) throw new Error('MockResponse constructor: url is null or undefined. RepsponseId=' + id);
            if (!urlCondition) throw new Error('MockResponse constructor: urlCondition is null or undefined. RepsponseId=' + id);
            if (!status) throw new Error('MockResponse constructor: status is null or undefined. RepsponseId=' + id);
            if (!data) throw new Error('MockResponse constructor: data is null or undefined. RepsponseId=' + id);
            if (!headers) throw new Error('MockResponse constructor: headers is null or undefined. RepsponseId=' + id);
            if (!_.isString(redirect)) throw new Error('MockResponse constructor: parameter "redirect" must be a string. RepsponseId=' + id);

            if (urlCondition !== UrlConditions.STARTS_WITH && urlCondition !== UrlConditions.CONTAINS && urlCondition !== UrlConditions.EQUAL)
                throw new Error('MockResponse constructor: urlCondition must be "STARTS_WITH" or "CONTAINS" or "EQUAL"');

            id = id;
            method = method.toUpperCase();
        }

        mockResponseonstructor();

        var me = this;

        this.getId = function () { return id; }
        this.getMethod = function () { return method; }
        this.getUrl = function () { return url; }
        this.getUrlCondition = function () { return urlCondition; }
        this.getStatus = function () { return status; }
        this.getData = function () { return data; }
        this.getHeaders = function () { return headers; }
        this.getRedirect = function () { return redirect; }

        this.isMatch = function (requestMethod, requestUrl) {
            if (requestMethod !== me.getMethod())
                return false;

            var urlIndex = requestUrl.indexOf(me.getUrl());

            if (me.getUrlCondition() === UrlConditions.STARTS_WITH) {
                return urlIndex === 0;
            } else if (me.getUrlCondition() === UrlConditions.CONTAINS) {
                return urlIndex !== -1;
            } else if (me.getUrlCondition() === UrlConditions.EQUAL) {
                return requestUrl === me.getUrl();
            }

            throw new Error('Unknown url condition: ' + response.getUrlCondition() + ' ResponseId=' + response.getId());
        }
    }

    function ConstantMock(id, response) {

        function constantMockConstructor() {
            if (!id) throw new Error('ConstantMock constructor: id is null or undefined');
            if (!response) throw new Error('ConstantMock constructor: response is null or undefined. MockId=' + id);
        }

        constantMockConstructor();

        this.getId = function () {
            return id;
        }

        this.isMatch = function (method, url, data, headers) {
            return response.isMatch(method, url);
        }

        this.getResponse = function (method, url, data, headers) {
            return response;
        }

        this.reset = function () { }

        this.getMethod = function () { return response.getMethod(); }
        this.getUrl = function () { return response.getUrl(); }
        this.getUrlCondition = function () { return response.getUrlCondition(); }
    }

    function LimitedMock(id, responseLimit, response) {

        var _currentLimit = null;

        function limitedMockConstructor() {
            if (responseLimit)
                responseLimit = parseInt(responseLimit);

            if (!id) throw new Error('LimitedMock constructor: id is null or undefined');
            if (!response) throw new Error('LimitedMock constructor: response is null or undefined. MockId=' + id);
            if (!_.isNumber(responseLimit) || responseLimit <= 0) throw new Error('LimitedMock constructor: responseLimit must be positive Integer. MockId=' + id + '. ResponseLimit=' + responseLimit);

            _currentLimit = responseLimit;
        }

        limitedMockConstructor();

        this.getId = function () {
            return id;
        }

        this.isMatch = function (method, url, data, headers) {
            return response.isMatch(method, url) && _currentLimit > 0;
        }

        this.getResponse = function (method, url, data, headers) {
            if (_currentLimit <= 0)
                throw new Error('LimitedMock.getResponse() : Limit exceed. Interceptor & Nobackend are out of sync! MockId=' + id);

            _currentLimit--;
            return response;
        }

        this.reset = function () {
            _currentLimit = responseLimit;
        }

        this.getMethod = function () { return response.getMethod(); }
        this.getUrl = function () { return response.getUrl(); }
        this.getUrlCondition = function () { return response.getUrlCondition(); }
    }

    function SequenceMock(id, repeatCount, responseSequence) {

        var _firstMethod = null;
        var _firstUrl = null;
        var _firstUrlCondition = null;
        var _currentIndex = 0;
        var _currentLapIndex = 0;

        function sequenceMockConstructor() {
            if (repeatCount)
                repeatCount = parseInt(repeatCount);

            if (!id) throw new Error('SequenceMock constructor: id is null or undefined');
            if (!_.isNumber(repeatCount) || repeatCount < -1) throw new Error('SequenceMock constructor: repeatCount must be a number > -2. MockId=' + id);
            if (!_.isArray(responseSequence) || responseSequence.length === 0) throw new Error('SequenceMock constructor: must be not empty array. MockId=' + id);

            _firstMethod = responseSequence[0].getMethod();
            _firstUrl = responseSequence[0].getUrl();
            _firstUrlCondition = responseSequence[0].getUrlCondition();

            if (_.any(responseSequence, function (response) {
                return response.getMethod() !== _firstMethod || response.getUrl() !== _firstUrl || response.getUrlCondition() !== _firstUrlCondition;
            })) {
                throw new Error('SequenceMock constructor: all responses must have identical URL. MockId=' + id);
            }
        }

        function isLimitOver() {
            if (repeatCount === -1)
                return false;

            var totalResponses = (repeatCount + 1) * responseSequence.length;
            var currentResponse = _currentLapIndex * responseSequence.length + _currentIndex;

            return totalResponses === currentResponse;
        }

        sequenceMockConstructor();

        this.getId = function () {
            return id;
        }

        this.isMatch = function (method, url, data, headers) {
            return responseSequence[0].isMatch(method, url) && isLimitOver() === false;
        }

        this.getResponse = function (method, url, data, headers) {
            if (isLimitOver())
                throw new Error('SequenceMock.getResponse() : Limit is over. Interceptor & Nobackend are out of sync!. MockId=' + id);

            if (_currentIndex === responseSequence.length) {
                _currentIndex = 0;
                _currentLapIndex++;
            }

            return responseSequence[_currentIndex++];
        }

        this.reset = function () {
            _currentIndex = 0;
            _currentLapIndex = 0;
        }

        this.getMethod = function () { return _firstMethod; }
        this.getUrl = function () { return _firstUrl; }
        this.getUrlCondition = function () { return _firstUrlCondition; }
    }

    function BusinessMock(id, businessResponses, canResolveFunction, resolveFunction) {

        var _firstMethod = null;
        var _firstUrl = null;
        var _firstUrlCondition = null;
        var _state = null;

        function businessMockConstructor() {
            if (!id) throw new Error('BusinessMock constructor: id is null or undefined');
            if (!_.isArray(businessResponses) || businessResponses.length === 0) throw new Error('BusinessMock constructor: businessResponses must be not empty array. MockId=' + id);
            if (!_.isFunction(canResolveFunction)) throw new Error('BusinessMock constructor: canResolveFunction must be a function. MockId=' + id);
            if (!_.isFunction(resolveFunction)) throw new Error('BusinessMock constructor: resolveFunction must be a function. MockId=' + id);

            _firstMethod = businessResponses[0].getMethod();
            _firstUrl = businessResponses[0].getUrl();
            _firstUrlCondition = businessResponses[0].getUrlCondition();

            _state = {};

            if (_.any(businessResponses, function (response) {
                return response.getMethod() !== _firstMethod || response.getUrl() !== _firstUrl || response.getUrlCondition() !== _firstUrlCondition;
            })) {
                throw new Error('SequenceMock constructor: all responses must have identical URL. MockId=' + id);
            }
        }

        businessMockConstructor();

        this.getId = function () {
            return id;
        }

        this.isMatch = function (method, url, data, headers) {
            return businessResponses[0].isMatch(method, url) && canResolveFunction(_state, method, url, data, headers) === true;
        }

        this.getResponse = function (method, url, data, headers) {
            var responseId = resolveFunction(_state, method, url, data, headers);

            // Выкидываем ошибку если функция Resolve возвратит ResponseId, которого нет в BusinessMockDefinition
            if (_.all(businessResponses, function (businessResponse) {
                return businessResponse.getId() !== responseId;
            })) {
                throw new Error('BusinessMock.getResponse() : ResolveFunction returned undeclared responseId: ' + responseId + '. MockId=' + id);
            }

            var response = self.getResponseById(responseId);

            if (!response)
                throw new Error('BusinessMock.getResponse() : Response was not found. MockId=' + id);

            return response;
        }

        this.reset = function () {
            _state = {}
        }

        this.getMethod = function () { return _firstMethod; }
        this.getUrl = function () { return _firstUrl; }
        this.getUrlCondition = function () { return _firstUrlCondition; }
    }

    function BusinessMockDefinition(id, responseIds, canResolveFunction, resolveFunction) {
        function businessMockDefinitionConstructor() {
            if (!id) throw new Error('BusinessMockDefinition constructor: id is null or undefined');
            if (!_.isArray(responseIds) || responseIds.length === 0) throw new Error('BusinessMockDefinition constructor: responseIds must be not empty array. MockId=' + id);
            if (!_.isFunction(canResolveFunction)) throw new Error('BusinessMockDefinition constructor: canResolveFunction must be a function');
            if (!_.isFunction(resolveFunction)) throw new Error('BusinessMockDefinition constructor: resolveFunction must be a function');
        }

        businessMockDefinitionConstructor();

        this.getId = function () { return id; }
        this.getResponseIds = function () { return responseIds; }
        this.getCanResolveFunction = function () { return canResolveFunction; }
        this.getResolveFunction = function () { return resolveFunction; }
    }

    // Пример context: P3.15
    function Scenario(id, name, context) {

        var _mockDefinitions = null; // массив различных типов: String, DynamicMockBuilder, BusinessMockBuilder

        function scenarioConstructor() {
            if (!id) throw new Error('Scenario constructor: id is null or undefined');
            if (!name) throw new Error('Scenario constructor: name is null or undefined. ScenarioId=' + id);
            if (!context) throw new Error('Scenario constructor: context is null or undefined. ScenarioId=' + id);

            _mockDefinitions = [];
        }

        scenarioConstructor();

        this.getId = function () { return id; }
        this.getName = function () { return name; }
        this.getContext = function () { return context; }
        this.getMockDefinitions = function () { return _mockDefinitions; }
    }

    function DynamicMockBuilder(mockDefinitionString, mockService) {

        var _isBuilt = false;
        var _mockTypeCode = null;
        var _responseIds = [];
        var _missingResponseIds = null;
        var _constructorParams = [];


        function dynamicMockBuilderConstructor() {
            if (_.isString(mockDefinitionString) == false)
                throw new Error('DynamicMockBuilder constructor. Parameter "mockDefinitionString" is not a string: ' + mockDefinitionString);

            mockDefinitionString = mockDefinitionString.substring(0, mockDefinitionString.length - 1);
            var mockDefParts = mockDefinitionString.split('(');
            _mockTypeCode = mockDefParts[0];
            var mockParams = mockDefParts[1].split(',');

            // Убираем пробелы
            for (var i = 0; i < mockParams.length; i++) {
                mockParams[i] = mockParams[i].trim();
            }

            if (_mockTypeCode !== 'CM' && _mockTypeCode !== 'LM' && _mockTypeCode !== 'SM')
                throw new Error('DynamicMockBuilder constructor :: unknown mock type code: ' + _mockTypeCode);

            if (_mockTypeCode === 'CM') {
                _responseIds.push(mockParams[0]);
            } else if (_mockTypeCode === 'LM') {
                _constructorParams.push(mockParams[0]);
                _responseIds.push(mockParams[1]);
            } else if (_mockTypeCode === 'SM') {
                _constructorParams.push(mockParams[0]);
                for (var i = 1; i < mockParams.length; i++) {
                    _responseIds.push(mockParams[i]);
                }
            }

            // Список зависимостей. Зарезолвеные зависимости отмечены знаком #
            _missingResponseIds = _.clone(_responseIds);

            // Резолвит возможные зависимости
            for (var i = 0; i < _mockResponses.length; i++) {
                for (var j = 0; j < _missingResponseIds.length; j++) {
                    if (_missingResponseIds[j] === _mockResponses[i].getId()) {
                        _missingResponseIds[j] = '#';
                    }
                }
            }
        }

        dynamicMockBuilderConstructor();

        this.raiseMockResponseAdded = function (mockResponse) {
            for (var j = 0; j < _missingResponseIds.length; j++) {
                if (_missingResponseIds[j] === mockResponse.getId()) {
                    _missingResponseIds[j] = '#';
                }
            }
        }

        this.canBuild = function () {
            return _.all(_missingResponseIds, function (responseId) { return responseId === '#'; });
        }

        this.getIsBuilt = function () {
            return _isBuilt;
        }

        this.build = function (dynamicId) {
            var mock;

            if (_mockTypeCode === 'CM') {
                var constantMockResponse = mockService.getResponseById(_responseIds[0]);
                mock = new ConstantMock(dynamicId, constantMockResponse);
            } else if (_mockTypeCode === 'LM') {
                var limitedMockResponse = mockService.getResponseById(_responseIds[0]);
                var limitCount = _constructorParams[0];
                mock = new LimitedMock(dynamicId, limitCount, limitedMockResponse);
            } else if (_mockTypeCode === 'SM') {
                var sequenceMockResponses = mockService.getResponsesByIds(_responseIds);
                var repeatCount = _constructorParams[0];
                mock = new SequenceMock(dynamicId, repeatCount, sequenceMockResponses);
            } else {
                throw new Error('MockPreparation.build :: unknown mock type code: ' + _mockTypeCode);
            }

            _isBuilt = true;
            return mock;
        }

        this.checkIntegrity = function () {
            _.each(_missingResponseIds, function (responseId) {
                if (responseId != '#')
                    console.warn('DynamicMock is broken - missing ResponseId: ' + responseId);
            });
        }
    }

    function BusinessMockBuilder(businessMockDefinition, mockService) {

        var _isBuilt = false;
        var _responseIds = [];
        var _missingResponseIds = null;

        function businessMockBuilderConstructor() {
            _responseIds = businessMockDefinition.getResponseIds();
            _missingResponseIds = _.clone(_responseIds);

            // Резолвит возможные зависимости
            for (var i = 0; i < _mockResponses.length; i++) {
                for (var j = 0; j < _missingResponseIds.length; j++) {
                    if (_missingResponseIds[j] === _mockResponses[i].getId()) {
                        _missingResponseIds[j] = '#';
                    }
                }
            }
        }

        businessMockBuilderConstructor();

        this.raiseMockResponseAdded = function (mockResponse) {
            for (var j = 0; j < _missingResponseIds.length; j++) {
                if (_missingResponseIds[j] === mockResponse.getId()) {
                    _missingResponseIds[j] = '#';
                }
            }
        }

        this.canBuild = function () {
            return _.all(_missingResponseIds, function (responseId) { return responseId === '#'; });
        }

        this.getIsBuilt = function () {
            return _isBuilt;
        }

        this.build = function (dynamicId) {
            var businessMockId = businessMockDefinition.getId();
            var businessMockResponses = mockService.getResponsesByIds(_responseIds);
            var mock = new BusinessMock(businessMockId, businessMockResponses, businessMockDefinition.getCanResolveFunction(), businessMockDefinition.getResolveFunction());

            _isBuilt = true;
            return mock;
        }

        this.checkIntegrity = function () {
            _.each(_missingResponseIds, function (responseId) {
                if (responseId != '#')
                    console.warn('BusinessMock is broken - missing ResponseId: ' + responseId);
            });
        }
    }

    function ScenarioBuilder(mockDefinitions, resultingMockArrayRef) {

        var _mockBuilders = [];
        var _dynamicIdPrefix = 'DynamicMock_';
        var _dynamicId = 0;

        // Сканирует текущую базу ответов и по возможности билдит моки
        function scenarioBuilderConstructor() {

            if (_.isArray(mockDefinitions) === false)
                throw new Error('ScenarioBuilder constructor :: mockDefinitions is not array');
            if (_.isArray(resultingMockArrayRef) === false || resultingMockArrayRef.length !== 0)
                throw new Error('ScenarioBuilder constructor :: resultingMockArrayRef must be an empty array');

            // Распознать динамические и типизированные билдеры
            _.each(mockDefinitions, function (mockDefinition) {
                if (_.isString(mockDefinition)) {
                    _mockBuilders.push(new DynamicMockBuilder(mockDefinition, self));
                } else if (mockDefinition instanceof BusinessMockDefinition) {
                    _mockBuilders.push(new BusinessMockBuilder(mockDefinition, self));
                } else if (mockDefinition instanceof DynamicMockBuilder) {
                    _mockBuilders.push(mockDefinition);
                } else {
                    throw new Error('ScenarioBuilder constructor: unknown mock definition:' + mockDefinition);
                }
            });

            // Опросить статус готовности у билдеров. Если они готовы - сделать билд
            _.each(_mockBuilders, function (mockBuilder) {
                if (mockBuilder.getIsBuilt() === false && mockBuilder.canBuild() === true) {
                    var index = _mockBuilders.indexOf(mockBuilder);
                    resultingMockArrayRef[index] = mockBuilder.build(generateDynamicId());
                }
            });
        }

        function generateDynamicId() {
            var result = _dynamicIdPrefix + _dynamicId;
            _dynamicId++;
            return result;
        }

        scenarioBuilderConstructor();

        this.raiseMockResponseAdded = function (response) {
            _.each(_mockBuilders, function (mockPreparation) {
                if (mockPreparation.getIsBuilt() === false) {
                    mockPreparation.raiseMockResponseAdded(response);

                    if (mockPreparation.canBuild() === true) {
                        var index = _mockBuilders.indexOf(mockPreparation);
                        resultingMockArrayRef[index] = mockPreparation.build(generateDynamicId());
                    }
                }
            });
        }

        // Проверяет целостность построенного сценария. Уведомляет о не найденных ResponseId
        this.checkIntegrity = function () {
            for (var i = 0; i < _mockBuilders.length; i++) {
                _mockBuilders[i].checkIntegrity();
            }
        }
    }

    function ScenarioGenerationConfig() {

        // Убрать RequestId у request-state моков и установить UrlCondition: CONTAINS
        this.generalizeRequestStates = true;

        // Название сценария
        this.scenarioName = 'Auto generated scenario';
    }























    // ===========================================================================================
    // === Приватные поля сервиса ================================================================
    // ===========================================================================================

    var _mockResponses = [];
    var _scenarios = [];
    var _activeScenarioId = null; // Заполняется только если в URL есть ScenarioId
    var _scenarioBuilder = null; // Заполняется только если в URL есть код сценария
    var _activeMocks = []; // Активные моки на данный момент
    var _isLoaded = false; // Загружен ли мок сервис
    var _isEnabled = false; // Включен ли мокинг (HTTP Интерцептор)
    var _isRecording = false;
    var _urlPrefix = 'mockService/'; // Замоканные рест сервисы получат этот префикс в адресе
    var _postInitializationComplete = false; // Проведена ли инициализация перед первым использованием
    var _isInitialized = false;
    var _recordedResponseObjects = [];

    var _mockResponseRequiredFields = 'id, method, url, urlCondition, data, headers, redirect';

    var self = this;














    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // ^^^ Конструктор сервиса ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    function mockServiceConstructor() {
        var contextParams = getContextParams();

        if (contextParams.mock) {
            _isLoaded = true;

            if (contextParams.scenarioId && contextParams.scenarioId.length > 0) {

                _activeScenarioId = contextParams.scenarioId;
                _isEnabled = true;

                console.info('[Mocking]: Activating scenario by Id: ' + _activeScenarioId);

                var presentScenario = _.find(_scenarios, function (scenario) {
                    return scenario.getId() === _activeScenarioId;
                });

                if (presentScenario) {
                    clearActiveMocks();
                    _scenarioBuilder = new ScenarioBuilder(presentScenario.getMockDefinitions(), _activeMocks);
                }

            } else if (contextParams.scenario && contextParams.scenario.length > 0) {

                var mockPreparations = [];

                var scenarioUrl = contextParams.scenario; // Пример: CM(USER_FL)+LM(USER_FL,5)+SM(2, USER_FL, USER_UL, OPCON)
                var mockDefinitions = scenarioUrl.split('+');
                _.each(mockDefinitions, function (mockDefinition) {
                    mockPreparations.push(new DynamicMockBuilder(mockDefinition, self));
                });

                clearActiveMocks();
                _scenarioBuilder = new ScenarioBuilder(mockPreparations, _activeMocks);

                _isEnabled = true;
                console.info('[Mocking]: Activating scenario by URL code: ' + scenarioUrl);
            }

            if (contextParams.record) {
                _isRecording = true;
            }
        }
    }

    mockServiceConstructor();











    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // ^^^ Приватные функции ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    function getContext() {
        return $window.__contextParams.context;
    }

    function getContextParams() {
        return $window.__contextParams.params;
    }

    // Возвращает абсолютный путь до начала контекста
    // Пример: http://local.nitec.kz:3000/P40.40/  ->  http://local.nitec.kz:3000
    // Пример: http://egovtest.nitec.kz/services/P40.40/  ->  http://egovtest.nitec.kz/services
    function getContextOrigin() {
        var origin = $window.location.href.split(getContext())[0];
        return origin;
    }

    // Является ли URL абсолютным (простая проверка на наличие протокола)
    function isAbsoluteUrl(url) {
        return url.indexOf($window.location.protocol) !== 0;
    }

    //TODO: нужно поменять проверку на случай когда само значение data: false. Чтобы это не принималось как ошибка, а как значение
    function isValidMockResponse(response) {
        return response['id'] && response['method'] && response['url'] && response['urlCondition'] && response['data'] && response['headers'] && _.isString(response['redirect']);
    }

    function getMatchingMock(method, url, data, headers) {
        // Сюда поступают метод и url из интерцепторов
        // URL могут быть двух типов, с префиксом и без. Пример:
        // "rest/current-user"
        // "mockService/rest/current-user"

        method = method.toUpperCase();

        if (url.indexOf(_urlPrefix) === 0)
            url = url.substring(_urlPrefix.length);

        return _.find(_activeMocks, function (mock) {
            if (_.isUndefined(mock) === true)
                return false;

            return mock.isMatch(method, url, data, headers) === true;
        });
    }

    function clearActiveMocks() {
        _activeMocks = [];
    }

    // Инициализация перед первым использованием (после того как все моки и сценарии зарегистрированы)
    function postInitialization() {

        // Тут нужно проверять целостность сценария, построенного по URL коду

        if (_activeScenarioId && _.all(_scenarios, function (scenario) { return scenario.getId() !== _activeScenarioId; }) === true)
            throw new Error('All scenarios registered, but ActiveScenario was not found by id: ' + _activeScenarioId);

        if (_scenarioBuilder)
            _scenarioBuilder.checkIntegrity();

        _postInitializationComplete = true;
    }
















    // ===========================================================================================
    // === Интерфейс сервиса =====================================================================
    // ===========================================================================================

    this.classes = {
        BusinessMockDefinition: BusinessMockDefinition,
        BusinessMock: BusinessMock,
        Scenario: Scenario,
        ScenarioGenerationConfig: ScenarioGenerationConfig
    }

    this.getIsLoaded = function () { return _isLoaded; } // есть ли параметр mock в URL
    this.getIsEnabled = function () { return _isEnabled; } // включен ли мокинг
    this.setIsEnabled = function (value) { _isEnabled = value; }
    this.getIsInitialized = function () { return _isInitialized; } // завершена ли инициализация (загружен ли мок файл)
    this.setIsInitialized = function (value) { _isInitialized = value; }
    this.getIsRecording = function () { return _isRecording; }
    this.setIsRecording = function (value) { _isRecording = value; }

    this.getScenarios = function () { return _scenarios; }
    this.getActiveMocks = function () { return _activeMocks; }

    this.getResponseById = function (responseId) {
        return _.find(_mockResponses, function (mockResponse) {
            return mockResponse.getId() === responseId;
        });
    }

    this.getResponsesByIds = function (responsesIds) {
        var result = [];
        for (var i = 0; i < responsesIds.length; i++) {
            result.push(self.getResponseById(responsesIds[i]));
        }
        return result;
    }










    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // ^^^ Функции для директивы mock-menu ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    // Применяет указанный сценарий (Вызывается из mock-menu.html)
    this.activateScenario = function (scenario) {
        clearActiveMocks();
        _scenarioBuilder = new ScenarioBuilder(scenario.getMockDefinitions(), _activeMocks);
    }

    // Удаляет активный мок (Вызывается из mock-menu.html)
    this.removeActiveMock = function (mock) {
        var index = _activeMocks.indexOf(mock);
        _activeMocks.splice(index, 1);
    }

    // TODO: RESET active mock

    // Возвращает URL для запуска сценария (Вызывается из mock-menu.html)
    this.getScenarioUrl = function (scenario) {
        var scenarioUrl = scenario.getContext() + '/?mock&scenarioId=' + scenario.getId();
        return getContextOrigin() + scenarioUrl;
    }









    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // ^^^ Функции для записи сценариев ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    this.addRecordedResponse = function (obj) {
        if (isValidMockResponse(obj) === false)
            throw new Error('$mockService.addRecordedResponse() :: Объект обязательно должен иметь поля: ' + _mockResponseRequiredFields);

        if (_.any(_mockResponses, function (response) { return response.getId() === obj.id; }) === true)
            throw new Error('$mockService.addRecordedResponse() :: ResponseId already exists: ' + obj.id);

        _recordedResponseObjects.push(obj);
    }

    this.clearRecordedResponses = function () {
        _recordedResponseObjects = [];
    }

    this.removeRecordedResponseObj = function (recordedResponseObj) {
        var index = _recordedResponseObjects.indexOf(recordedResponseObj);
        _recordedResponseObjects.splice(index, 1);
    }

    this.getRecordedResponses = function () {
        return _recordedResponseObjects;
    }

    // Выводит пользователю JavaScript код для регистрации сценария
    this.printRecordedScenario = function (config) {
        if (config instanceof ScenarioGenerationConfig === false)
            throw new Error('$mockService.printRecordedScenario() :: config must be instance of $mockService.classes.ScenarioGenerationConfig');

        var runStart = "app.run(['$mockService', function ($mockService) {";
        var runEnd = "}]);";
        var processCondition = "if ($mockService.getIsLoaded() === false) return;";

        return runStart + processCondition + generateScenarioPart(config) + generateResponseRegistration(config) + runEnd;

        // TODO: учесть баг с hierarchical-ar-dictionary ([null, obj, obj]);
        // TODO: добавить хелперы для автоматической обработки request-state моков
        // TODO: добавить визуальный редактор настроек генерации сценария

        function generateScenarioPart(cfg) {
            var scenarioId = new Date().getTime().toString();
            var scenarioContext = getContext();
            var scenarioDef = "var scenario = new $mockService.classes.Scenario('" + scenarioId + "', '" + cfg.scenarioName + "', '" + scenarioContext + "');";

            var mockDefinitions = "";
            _.each(_recordedResponseObjects, function (recordedResponseObject) {
                mockDefinitions += "scenario.getMockDefinitions().push('LM(1, " + recordedResponseObject.id + ")');";
            });

            var addScenario = "$mockService.addScenario(scenario);";

            return scenarioDef + mockDefinitions + addScenario;
        }

        function generateResponseRegistration(cfg) {
            if (cfg.generalizeRequestStates === true) {
                // Убирает привязку моков к RequestId
                _.each(_recordedResponseObjects, function (recordedResponseObj) {
                    if (recordedResponseObj.url.indexOf('rest/request-states') === 0) {
                        recordedResponseObj.url = 'rest/request-states';
                        recordedResponseObj.urlCondition = UrlConditions.STARTS_WITH;
                    }
                });
            }


            var responsesDef = "var recordedResponses = " + angular.toJson(_recordedResponseObjects) + ";";
            var registeringResponses = "_.each(recordedResponses, function(recordedResponse) { $mockService.addMockResponse(recordedResponse); });";
            return responsesDef + registeringResponses;
        }
    }








    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // ^^^ Функции для регистрации MockResponse & Scenario ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    this.addMockResponse = function (obj) {

        if (isValidMockResponse(obj) === false)
            throw new Error('$mockService.addMockResponse() :: Объект обязательно должен иметь поля: ' + _mockResponseRequiredFields);

        if (_.any(_mockResponses, function (response) { return response.getId() === obj.id; }) === true)
            throw new Error('$mockService.addMockResponse() :: ResponseId already exists: ' + obj.id);

        var mockResponse = new MockResponse(obj.id, obj.method, obj.url, obj.urlCondition, obj.status, obj.data, obj.headers, obj.redirect);

        _mockResponses.push(mockResponse);

        // Уведомляем билдеры о появлении нового Response
        if (_scenarioBuilder)
            _scenarioBuilder.raiseMockResponseAdded(mockResponse);
    }

    this.addScenario = function (newScenario) {
        if (newScenario instanceof Scenario === false)
            throw new Error('$mockService.addScenario :: parameter must be an instance of $mockService.classes.Scenario');

        if (_.any(_scenarios, function (scenario) { return scenario.getId() === newScenario.getId(); }) === true)
            throw new Error('$mockService.addScenario :: ScenarioId already exists: ' + newScenario.getId());

        _scenarios.push(newScenario);

        // Применяем сценарий если он указан в URL
        if (_activeScenarioId && _activeScenarioId === newScenario.getId()) {
            clearActiveMocks();
            _scenarioBuilder = new ScenarioBuilder(newScenario.getMockDefinitions(), _activeMocks);
        }
    }












    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // ^^^ Функции для http интерцептора и $noBackend ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    this.resolveResponse = function (method, url, data, headers) {

        if (url.indexOf(_urlPrefix) !== 0)
            throw new Error('$mockService.resolveResponse() :: Некорректный вызов метода. URL не содержит префикс "' + _urlPrefix + '". URL: ' + method + ' ' + url);

        var mock = getMatchingMock(method, url, data, headers);

        if (_.isObject(mock) === false)
            throw new Error('$mockService.resolveResponse() :: Не удалось найти подходящий мок объект. Метод getMatchingMock вернул разные результаты при вызове из canResolveResponse и resolveResponse. URL: ' + method + ' ' + url);

        var response = mock.getResponse(method, url, data, headers);

        if (isValidMockResponse(response) === false)
            throw new Error('$mockService.resolveResponse() :: Мок с идентификатором "' + mock.getId() + '" вернул некорректный Response объект. Объект обязательно должен иметь поля: ' + _mockResponseRequiredFields);

        if (response.getRedirect().length > 0) {
            var redirectUrl = response.getRedirect();
            if (isAbsoluteUrl(redirectUrl))
                redirectUrl = getContextOrigin() + redirectUrl;


            var dialogResult = $window.confirm('Требуется подтверждение для перехода на следующую страницу: ' + redirectUrl);
            if (dialogResult === true)
                $window.location = redirectUrl;

        }

        return response;
    }

    this.canResolveResponse = function (method, url, data, headers) {
        if (_postInitializationComplete === false)
            postInitialization();

        return _.isObject(getMatchingMock(method, url, data, headers)) === true;
    }

    this.addUrlPrefix = function (url) {
        return _urlPrefix + url;
    }

    this.hasUrlPrefix = function (url) {
        return url.indexOf(_urlPrefix) === 0;
    }

    return this;
}]);











// Эмулирует ответы от бэкенда, если адрес запроса содержит префикс мок сервиса
app.run(['$mockService', '$httpBackend', '$http', function ($mockService, $httpBackend, $http) {

    if ($mockService.getIsLoaded() === true) {

        $http.get('kit/mocks/common-mock.json').success(function (arrayOfResponses) {
            _.each(arrayOfResponses, function (response) {
                $mockService.addMockResponse(response);
            });
            console.info('[Mocking]: Mock files loaded');
            $mockService.setIsInitialized(true);
        }).error(function () {
            console.error('Loading "kit/mocks/common-mock.json" failed');
        });
    }

    var resolveMockFunction = function (method, url, data, headers) {
        console.info('[Mocking]: ' + method + ' ' + url);
        var response = $mockService.resolveResponse(method, url, data, headers);
        return [response.getStatus(), response.getData(), response.getHeaders()];
    };

    $httpBackend.whenGET(function (url) { return $mockService.hasUrlPrefix(url); }).respond(resolveMockFunction);
    $httpBackend.whenPOST(function (url) { return $mockService.hasUrlPrefix(url); }).respond(resolveMockFunction);
    $httpBackend.whenGET(/.*/).passThrough();
    $httpBackend.whenPOST(/.*/).passThrough();
    $httpBackend.whenJSONP(/.*/).passThrough();
}]);


// Интерцептор, проверяющий статус мок сервиса и возможность применить мок. Модифицирует URL если можно применить мок
app.config(function ($httpProvider, $provide) {
    $provide.factory('mockServiceHttpInterceptor', ['$mockService', '$interval', '$q', function ($mockService, $interval, $q) {
        function validateMockableUrl(url) {
            return url.indexOf('.html') === -1 && url.indexOf('.json') === -1 && url.indexOf('.txt') === -1;
        }

        return {
            'request': function (config) {

                // Обрабатывает запрос если мок система включена, запрос не направлена на kit/mocks и запрос не загружает html
                if ($mockService.getIsEnabled() === true && validateMockableUrl(config.url)) {
                    if ($mockService.getIsInitialized() === false) {
                        var defer = $q.defer();
                        var intervalPromise = $interval(function () {
                            if ($mockService.getIsInitialized() === true) {
                                $interval.cancel(intervalPromise);

                                if ($mockService.canResolveResponse(config.method, config.url, config.data, config.headers))
                                    config.url = $mockService.addUrlPrefix(config.url);

                                defer.resolve(config);
                            }
                        }, 500);
                        return defer.promise;
                    } else {
                        if ($mockService.canResolveResponse(config.method, config.url, config.data, config.headers))
                            config.url = $mockService.addUrlPrefix(config.url);
                    }
                }

                return config;
            },

            'response': function (response) {
                if ($mockService.getIsRecording() === true && validateMockableUrl(response.config.url)) {
                    var obj = {
                        id: new Date().getTime().toString(),
                        method: response.config.method,
                        url: response.config.url,
                        urlCondition: 'EQUAL',
                        status: response.status,
                        data: response.data,
                        headers: {},
                        redirect: ''
                    }
                    $mockService.addRecordedResponse(obj);
                }
                return response;
            },
        };
    }]);

    $httpProvider.interceptors.push('mockServiceHttpInterceptor');
});
