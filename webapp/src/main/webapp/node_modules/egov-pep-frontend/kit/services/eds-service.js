angular.module("app").service('$eds', [ '$http', '$q', '$rootScope', '$timeout', '$perf', '$cookie', '$interval', '$injector', '$settings', '$location', '$templateCache',
    function ($http, $q, $rootScope, $timeout, $perf, $cookie, $interval, $injector, $settings, $location, $templateCache) {
        console.info(">>> No perfomance calc for POD mode");

        $rootScope.$eds = this; //global service

        var instances = {}, storageUin = null;

        function iFramed() {
            if (parent.SignApplet && parent.FindKey) return true;
            else return false;
        };

        this.init = function (namespace, $scope) {
            if (instances[namespace]) {
                console.log('Ошибка - компонент подписания для пространства ' + namespace + ' уже создан');
                return;
            }
            var edsInstance = new Eds(namespace, $scope);
            if (storageUin) edsInstance.enableStorage(storageUin);
            instances[edsInstance.namespace] = edsInstance;
        };

        this.open = function (namespace, options) {
            if (!instances[namespace]) return;
            instances[namespace].open(options);
        };

        this.reset = function (namespace) {
            if (!instances[namespace]) return;
            instances[namespace].reset();
        };

        this.getCertInfo = function (namespace) {
            if (!instances[namespace]) return null;
            return instances[namespace].getCertInfo();
        };

        this.apply = function (namespace, xml) {
            if (!instances[namespace]) return;
            instances[namespace].apply(xml);
        };

        this.enableStorage = function (namespace, uin) {
            if (!instances[namespace]) return null;
            instances[namespace].enableStorage(uin);
        };

        this.resetStorage = function (namespace) {
            if (!instances[namespace]) return null;
            instances[namespace].resetStorage();
        };

        this.addTestFileCert = function (namespace, pathToFileCert, password) {
            if (!instances[namespace]) return null;
            instances[namespace].addTestFileCert(pathToFileCert, password);
        };

        this.setAllowedUin = function (namespace, value) {
            if (!instances[namespace]) return null;
            instances[namespace].setAllowedUin(value);
        };

        function Eds(namespaceName, $scope) {

            var CONST = {
                APPLET_SIZE: 2465792,
                APPLET_LOADING_TIMEOUT: 2 * 60 * 60 * 1000,
                KAZTOKEN_SLOT: 15,
                IDCARD_SLOT: 14,
                APPLET_FILECHOOSE_CALLBACK: "appletFilechooserCallback" + uid(),
                KEYSTORE_TYPE: 17,
                SLOT_REFRESH_INTERVAL: 1000
            };
            var signWrapper = null;

            function getSignWrapper() {
                if (signWrapper)
                    return signWrapper.get()
                else
                    return signWrapper;
            };

            /* TODO 'sign2' добавлен как костыль согласован с Витей. namespace подписания требует дороботки
             *  @Duman
             * */

            if (!_.contains([ 'auth', 'sign', 'sign2', 'agreement', 'sign3', 'sign4' ], namespaceName)) {
                error("Namespace " + namespaceName + "is not supported by EDS");
                return;
            }


            var namespace = {
                value: namespaceName,
                path: function (key) {
                    return namespaceName + "." + key;
                },
                keyFunc: function () {
                    return "getKeyStoreUsableValid" + (namespaceName == "agreement" || namespaceName == "sign2" ? "sign" : namespaceName).capitalize() + "Keys";
                }
            };
            $scope.namespace = namespaceName;
            $scope.refreshScreen = function () {
                $('body').css('overflow', 'hidden').height();
                $('body').css('overflow', 'auto');
            };

            var storageUin = null;
            var cookies = (function () {

                var Cookie = function (key) {
                    return {
                        get: function () {
                            if ((storageUin && $cookie.get('uin') == storageUin) || $settings.isPep()) {
                                return $cookie.get(namespace.path(key));
                            }
                            return "";
                        },
                        set: function (val) {
                            if (storageUin || $settings.isPep()) {
                                $cookie.setTo(namespace.path(key), val, "/");
                                if (storageUin) {
                                    $cookie.setTo('uin', storageUin, "/");
                                }
                            }
                        },
                        remove: function () {
                            $cookie.deleteFrom(namespace.path(key), "/");
                        },
                        exist: function () {
                            if ((storageUin && $cookie.get('uin') == storageUin) || $settings.isPep()) {
                                return !!$cookie.get(namespace.path(key));
                            }
                            return false;
                        }
                    };
                };

                var cookies = {
                    certType: {},
                    file: {},
                    kaztoken: {},
                    idcard: {},
                    password: {}
                };

                _.each(_.keys(cookies), function (key) {
                    cookies[key] = new Cookie(key);
                });

                return cookies;
            })();

            var webSocket = {};
            var heartbeat_msg = '--heartbeat--';
            var heartbeat_interval = null;
            var missed_heartbeats = 0;
            var missed_heartbeats_limit = 3;
            var wsCallback = null;
            var stateCallback = null;

            function setMissedHeartbeatsLimitToMax() {
                missed_heartbeats_limit = 50;
            }

            function setMissedHeartbeatsLimitToMin() {
                missed_heartbeats_limit = 3;
            }

            function initSocket() {
                try {
                    webSocket = new WebSocket('wss://localhost:13579/');

                    webSocket.onopen = function (event) {
                        if (heartbeat_interval === null) {
                            missed_heartbeats = 0;
                            heartbeat_interval = setInterval(pingLayer, 2000);
                        }
                        if (!signWrapper) {
                            signWrapper = WSSign;
                            console.log("Connection opened");
                            stateCallback && stateCallback();
                        } else {
                            if(event.type === 'open'){
                                signWrapper = WSSign;
                                console.log("Connection opened...");
                                stateCallback && stateCallback();
                            }else{
                                console.log("Connection close...");
                                webSocket && webSocket.close();
                            }
                        }
                    };

                    webSocket.onerror = function (event) {
                        if (!signWrapper && (webSocket.readyState == 2 || webSocket.readyState == 3)) {
                            window.setTimeout(initSocket(), 10000)
                        }
                    };
                    /*
                     CONNECTING	0	The connection is not yet open.
                     OPEN	1	The connection is open and ready to communicate.
                     CLOSING	2	The connection is in the process of closing.
                     CLOSED	3	The connection is closed or couldn't be opened.
                     */

                    webSocket.onclose = function (event) {
                        if (event.wasClean) {
                            console.log('connection has been closed');
                        } //else {
                        //console.log('Connection error');
                        //}
                        console.log('Code: ' + event.code + ' Reason: ' + event.reason);
                    };

                    webSocket.onmessage = function (event) {
                        if (event.data === heartbeat_msg) {
                            missed_heartbeats = 0;
                            return;
                        }
                        var result = JSON.parse(event.data);
                        if(result.message != null || result.result != null){
                            if(result.message == 'action.canceled' || result.result != null){
                                missed_heartbeats = 0;
                                return;
                            }
                        }
                        setMissedHeartbeatsLimitToMin();
                        getSignWrapper()[wsCallback](result);
                    };
                } catch (e) {
                    console.log("WebSocket init error: " + e);
                }
            };
            function pingLayer() {
                try {
                    missed_heartbeats++;
                    if (missed_heartbeats >= missed_heartbeats_limit)
                        throw new Error("Too many missed heartbeats.");
                    webSocket.send(heartbeat_msg);
                } catch (e) {
                    clearInterval(heartbeat_interval);
                    heartbeat_interval = null;
                    console.warn("Closing connection. Reason: " + e.message);
                    webSocket.close();
                }
            };

            function clearCookies() {
                cookies.certType.remove();
                cookies.file.remove();
                cookies.kaztoken.remove();
                cookies.idcard.remove();
                cookies.password.remove();
                $scope.cookieExists = false;
                $cookie.deleteFrom('uin', "/");
            };

            var WSSign = {
                profile: null,
                password: null,
                storageType: null,
                keyPath: null,
                keyAlias: null,
                notAfter: null,
                notBefore: null,
                signIdx: 0,
                signArray: null,
                signedXmlsArray: null,
                get: function () {
                    return this;
                },
                /*вызова окна для выбора файла с ЭЦП, вместо chooseFile*/
                browseKeyStore: function (storageType, fileExtention, currentDirectory, profile) {
                    // var callData = {
                    //     "method": "browseKeyStore",
                    //     "args": [storageType, fileExtention, currentDirectory]
                    // };
                    // this.profile = profile;
                    // setMissedHeartbeatsLimitToMax();
                    // wsCallback = 'browseKeyStoreCallBack';
                    // webSocket.send(JSON.stringify(callData));
                    callbacks.onCert(null);
                },
                browseKeyStoreCallBack: function (result) {
                    this.profile.browseKeyStoreCallBack(this.convertResponce(result));
                },
                /*для проверки наличия в системе казтокена, или удостоверения личности, вместо getSlotList*/
                loadSlotList: function (storageType, profile) {
                    var callData = {
                        "method": "loadSlotList",
                        "args": [storageType]
                    };
                    this.profile = profile;
                    setMissedHeartbeatsLimitToMax();
                    wsCallback = 'loadSlotListCallBack';
                    webSocket.send(JSON.stringify(callData));
                },
                loadSlotListCallBack: function (result) {
                    this.profile.loadSlotListCallBack(this.convertResponce(result));
                },

                getActiveTokens: function(storageType, profile) {
                var getActiveTokens = {
                    "module": "kz.gov.pki.knca.commonUtils",
                    "method": "getActiveTokens"
                };
                    this.profile = profile;
                    wsCallback = 'getActiveTokensBack';
                    setMissedHeartbeatsLimitToMax();
                    webSocket.send(JSON.stringify(getActiveTokens));
                },
                getActiveTokensBack: function(result) {
                    this.profile.getActiveTokensBack(result);
                },

                /*возвращает списк ключей в ключевом контейнере, а так же для проверки правильности указания пин-кода, вместо checkPassword, getKeyStoreUsableValidAuthKeys, getKeyStoreUsableValidSignKeys*/
                getKeys: function (storageType, keyPath, pwd, keyType, profile) {
                    var callData = {
                        "method": "getKeys",
                        "args": [storageType, keyPath, pwd, keyType]
                    };
                    this.profile = profile;
                    setMissedHeartbeatsLimitToMax();
                    wsCallback = 'getKeysCallBack';
                    this.password = pwd;
                    webSocket.send(JSON.stringify(callData));
                },
                getKeysCallBack: function (result) {
                    this.profile.getKeysCallBack(this.convertResponce(result), this.password);
                },
                /*подписания XML-документа*/
                signXml: function (storageType, keyPath, keyAlias, password, xmlsToSign, profile) {
                    var signArray = [];
                    if (typeof xmlsToSign === "string") {
                        signArray.push(xmlsToSign);
                    } else {
                        _.each(xmlsToSign, function (xml) {
                            signArray.push(xml);
                        });
                    }
                    this.signArray = signArray;
                    this.signIdx = 0;
                    this.signedXmlsArray = [];
                    this.storageType = storageType;
                    this.keyPath = keyPath;
                    this.keyAlias = keyAlias;
                    this.password = password;
                    this.profile = profile;
                    var callData = {
                        "method": "signXml",
                        "args": [storageType, keyPath, keyAlias, password, this.signArray[0]]
                    };
                    setMissedHeartbeatsLimitToMax();
                    wsCallback = 'signXmlCallBack';
                    webSocket.send(JSON.stringify(callData));
                },
                /*подписания XML-документа новый NCALayer*/
                signXmlNew: function (storageType, xmlsToSign, profile) {
                    var signArray = [];
                    if (typeof xmlsToSign === "string") {
                        signArray.push(xmlsToSign);
                    } else {
                        _.each(xmlsToSign, function (xml) {
                            signArray.push(xml);
                        });
                    }
                    this.signArray = signArray;
                    this.signIdx = 0;
                    this.signedXmlsArray = [];
                    this.storageType = storageType;
                    //this.keyPath = keyPath;
                    //this.keyAlias = keyAlias;
                    //this.password = password;
                    this.profile = profile;
                    var callData = {
                        "module": "kz.gov.pki.knca.commonUtils",
                        "method": "signXml",
                        "args": [storageType, "SIGNATURE", this.signArray[0], "", ""]
                    };
                    setMissedHeartbeatsLimitToMax();
                    wsCallback = 'signXmlCallBack';
                    webSocket.send(JSON.stringify(callData));
                },
                signXmlCallBack: function (result) {
                    this.signedXmlsArray[this.signIdx++] = result.responseObject;
                    if (this.signedXmlsArray.length == this.signArray.length) {
                        if (this.signedXmlsArray.length > 1) {
                            this.profile.signXmlCallBack(this.signedXmlsArray);
                        } else this.profile.signXmlCallBack(this.signedXmlsArray[0]);
                        return;
                    }
                    var callData = {
                        "module": "kz.gov.pki.knca.commonUtils",
                        "method": "signXml",
                        "args": [this.storageType, "SIGNATURE", this.signArray[this.signIdx], "", ""]
                    };
                    setMissedHeartbeatsLimitToMax();
                    wsCallback = 'signXmlCallBack';
                    webSocket.send(JSON.stringify(callData));
                },
                getSubjectDNCallBack: function (result) {
                    var retVal = {};
                    retVal.notAfter = this.notAfter;
                    retVal.notBefore = this.notBefore;
                    retVal.subjectDN = result.result;
                    this.profile.getCertificateInfoCallBack(retVal, this.password, this.keyPath);
                },
                getNotBeforeCallBack: function (result) {
                    this.notBefore = result.result;
                    var callData = {
                        "method": "getSubjectDN",
                        "args": [this.storageType, this.keyPath, this.keyAlias, this.password]
                    };
                    setMissedHeartbeatsLimitToMax();
                    wsCallback = 'getSubjectDNCallBack';
                    webSocket.send(JSON.stringify(callData));
                },
                getNotAfterCallBack: function (result) {
                    this.notAfter = result.result;
                    var callData = {
                        "method": "getNotBefore",
                        "args": [this.storageType, this.keyPath, this.keyAlias, this.password]
                    };
                    setMissedHeartbeatsLimitToMax();
                    wsCallback = 'getNotBeforeCallBack';
                    webSocket.send(JSON.stringify(callData));
                },
                getCertificateInfo: function (storageType, keyPath, keyAlias, password, profile) {
                    var callData = {
                        "method": "getNotAfter",
                        "args": [storageType, keyPath, keyAlias, password]
                    };
                    this.profile = profile;
                    this.storageType = storageType;
                    this.keyPath = keyPath;
                    this.keyAlias = keyAlias;
                    this.password = password;
                    setMissedHeartbeatsLimitToMax();
                    wsCallback = 'getNotAfterCallBack';
                    webSocket.send(JSON.stringify(callData));
                },
                convertResponce: function (wsResponce) {
                    wsResponce.getErrorCode = function () {
                        return this.errorCode;
                    };

                    wsResponce.getResult = function () {
                        return this.result;
                    };

                    wsResponce.getSecondResult = function () {
                        return this.secondResult;
                    };
                    return wsResponce;
                },
                destroy: function () {
                    signWrapper = null;
                    clearInterval(heartbeat_interval);
                    heartbeat_interval = null;
                    webSocket.close();
                }
            };

            var applet = {
                get: function () {
                    return document.SignAppletProxy;
                },
                create: function (callback) {
                    if (applet.get()) return;

                    window.AppletIsReady = function () {
                        (function wrap() {

                            var appletObj = null;
                            if (iFramed()) appletObj = parent.SignApplet;
                            else  appletObj = document.SignApplet;
                            var testMode = false;

                            document.SignAppletProxy = {
                                /*подписания XML-документа*/
                                signXml: function (storageType, keyPath, keyAlias, password, xmlsToSign, profile) {
                                    var result;
                                    if (typeof xmlsToSign === "string") {
                                        result = appletObj.signXml(storageType, keyPath, keyAlias, password, xmlsToSign).getResult();
                                    } else {
                                        result = [];
                                        _.each(xmlsToSign, function (xml) {
                                            var signedXML = appletObj.signXml(storageType, keyPath, keyAlias, password, xml).getResult();
                                            result.push(signedXML);
                                        });
                                    }
                                    profile.signXmlCallBack(result);
                                },
                                /*возвращает DN-имя субъекта сертификата, т.е. информацию о том на кого выдан сертификат*/
                                getSubjectDN: function (storageType, keyPath, alias, password) {
                                    return appletObj.getSubjectDN(storageType, keyPath, alias, password);
                                },
                                /*возвращает время начала срока действия сертификата. Формат возвращаемой даты dd.MM.yyyy */
                                getNotBefore: function (storageType, keyPath, keyAlias, password) {
                                    return appletObj.getNotBefore(storageType, keyPath, keyAlias, password);
                                },
                                /*возвращает время окончания срока действия сертификата. Формат возвращаемой даты dd.MM.yyyy */
                                getNotAfter: function (storageType, keyPath, keyAlias, password) {
                                    return appletObj.getNotAfter(storageType, keyPath, keyAlias, password);
                                },
                                getCertificateInfo: function (storageType, keyPath, keyAlias, password, profile) {
                                    var retVal = {};
                                    retVal.notAfter = this.getNotAfter(storageType, keyPath, keyAlias, password).getResult();
                                    retVal.notBefore = this.getNotBefore(storageType, keyPath, keyAlias, password).getResult();
                                    retVal.subjectDN = this.getSubjectDN(storageType, keyPath, keyAlias, password).getResult();
                                    profile.getCertificateInfoCallBack(retVal, password, keyPath);
                                },
                                /*для проверки наличия в системе казтокена, или удостоверения личности, вместо getSlotList*/
                                loadSlotList: function (storageType, profile) {
                                    var retVal = appletObj.loadSlotList(storageType);
                                    profile.loadSlotListCallBack(retVal);
                                },
                                /*возвращает списк ключей в ключевом контейнере, а так же для проверки правильности указания пин-кода, вместо checkPassword, getKeyStoreUsableValidAuthKeys, getKeyStoreUsableValidSignKeys*/
                                getKeys: function (storageType, keyPath, password, keyType, profile) {
                                    var retVal = appletObj.getKeys(storageType, keyPath, password, keyType);
                                    profile.getKeysCallBack(retVal, password);
                                },
                                /*вызова окна для выбора файла с ЭЦП, вместо chooseFile*/
                                browseKeyStore: function (storageType, fileExtention, currentDirectory, profile) {
                                    var retVal = appletObj.browseKeyStore(storageType, fileExtention, currentDirectory);
                                    profile.browseKeyStoreCallBack(retVal);
                                }
                            };

                        })();
                        console.log("signWrapper = applet;");
                        signWrapper = applet;
                        $settings.isPep() && webSocket.close();
                        callback();
                    };

                    if (iFramed()) {
                        console.info("applet from iframe");
                        window.AppletIsReady();
                    } else {
                        var appletBase = 'http://pod.egov.kz/static-resources/sign-applet/applets'; //это на бой
                        //var appletBase = 'kit/directives/eds/applet';//это локально
                        if ($location.host() != 'localhost' && $location.host() != 'local.nitec.kz') {
                            if ($settings.isPod()) {
                                appletBase = '/static-resources/sign-applet/applets';
                            } else if ($settings.isPep()) {
                                appletBase = '/services/static-resources/sign-applet/applets';
                            }
                        }
                        console.info("applet from", appletBase);
                        var appletTemplate = $templateCache.get('kit/directives/eds/applet-template.html');
                        var appletEl = angular.element(appletTemplate);
                        appletEl.attr('codebase', appletBase);
                        appletEl.find('param[name=codebase]').attr('value', appletBase);
                        angular.element('body').append(appletEl);
                    }
                },
                destroy: function () {
                    $('applet').hide();
                }
            };

            var keyApplet = {
                get: function () {
                    return document.FindKeyAppletProxy;
                },
                create: function (callback) {
                    if (keyApplet.get()) return;

                    if (iFramed()) {
                        console.info("key applet from iframe");
                    } else {
                        var appletBase = 'http://pod.egov.kz/static-resources/sign-applet/applets';// это бой
                        //var appletBase = 'kit/directives/eds/applet';//это локально
                        if ($location.host() != 'localhost' && $location.host() != 'local.nitec.kz') {
                            if ($settings.isPod()) {
                                appletBase = '/static-resources/sign-applet/applets';
                            } else if ($settings.isPep()) {
                                appletBase = '/services/static-resources/sign-applet/applets';
                            }
                        }
                        console.info("key applet from", appletBase);
                        var keyAppletTemplate = $templateCache.get('kit/directives/eds/applet-key-template.html');
                        var appletEl = angular.element(keyAppletTemplate);
                        appletEl.attr('codebase', appletBase);
                        appletEl.find('param[name=codebase]').attr('value', appletBase);
                        angular.element('body').append(appletEl);
                    }

                    var delay = 100, // Интервал
                        appletListener = setInterval(function () { // listener прогрузки апплета
                            var appletObj = iFramed() ? parent.FindKey : document.FindKey;
                            if (!appletObj || typeof appletObj.isActive !== 'function' || !appletObj.isActive()) return; // если не инициализирован, то ждем

                            document.FindKeyAppletProxy = {
                                getAllDirs: function (path) {
                                    return path && Array.prototype.slice.call(appletObj.getDirsIn(path)) || null;
                                },
                                getAllFiles: function (path) {
                                    return path && Array.prototype.slice.call(appletObj.getFilesIn(path)) || null;
                                },
                                getFilePath: function (path, file) {
                                    return file && path.push(file) && appletObj.getFullPath(appletObj.getPath(path)) || null;
                                },
                                findFirstKey: function () {
                                    return appletObj.findFirstKey();
                                }
                            };
                            if (appletListener) { // Дождавшись апплета
                                clearInterval(appletListener);
                                appletListener = null;
                            }
                            callback();
                        }, delay);

                    setTimeout(function () { // Если апплет никак не прогружается, по разным причинам, прикратить ожидание спустя N попыток
                        if (appletListener) {
                            clearInterval(appletListener);
                            appletListener = null;
                        }
                    }, delay * 10);

                },
                destroy: function () {
                    $('keyApplet').remove();
                }
            };

            var profile = (function () {

                var active = null;

                var BaseProfile = function (storage) {

                    return {
                        storage: storage,
                        allKeys: null,
                        dateFrom: null,
                        dateTo: null,
                        key: null,
                        keyId: null,
                        type: null,
                        path: null,
                        password: null,
                        requirePassword: true,
                        loadFromCookie: function () {
                            this.validateCookie();
                        },
                        activate: function () {
                            active = this;
                        },
                        sign: function () {
                            this.saveCookie();
                            this.password = null;
                            this.requirePassword = true;
                        },
                        isActive: function () {
                            return active == this;
                        },
                        hash: function () {
                            return this.allKeys;//todo можно возвращать хэш от массива ключей, но не важно
                        },
                        parse: function () {
                            var attrs = this.key;
                            var details = {};
                            _.each(attrs.split(','), function (e) {
                                var d = e.split('=');
                                details[d[0].replace(" ", "")] = d[1];
                            });

                            var credentials = details['CN'].split(" ");
                            certInfo = {
                                dateFrom: this.dateFrom.split(' ')[0],
                                dateTo: this.dateTo.split(' ')[0],
                                iin: details.SERIALNUMBER.substr(3),
                                email: details.E,
                                lastName: credentials[0],
                                firstName: credentials[1],
                                middleName: details.G || details.GIVENNAME,
                                bin: details.OU,
                                organizationName: details.O,
                                isIin: details.SERIALNUMBER.substr(0, 3)
                            };
                            if (certInfo.bin && certInfo.bin.length > 3) certInfo.bin = certInfo.bin.substr(3);
                            certInfo.uin = certInfo.bin ? certInfo.bin : certInfo.iin;
                            return certInfo;
                        },
                        accessKey: function (keysResult, path, password) {

                            function filterEmptyKeys(keys) {
                                return _.filter(keys.split('\n'), function (val) {
                                    return val != "";
                                });
                            };
                            this.allKeys = filterEmptyKeys(keysResult.getResult());
                            if (this.allKeys == null || _.isEmpty(this.allKeys)) {
                                return state.waitingPin.afterCheckPassword(password, {'msg': 'noKeys'});
                            }

                            if (this.allKeys.length > 1)
                                return state.waitingPin.afterCheckPassword(password, {'msg': "multikeyUnsupported"}); //правильней было бы дать возможность выбрать ключ

                            getSignWrapper().getCertificateInfo(this.storage, path, this.allKeys[0].split("|")[3], password, this);
                        },
                        getCertificateInfoCallBack: function (result, password, path) {
                            function getEndDate(str) {
                                var arr = str.split("|");
                                var date = arr[arr.length - 1];
                                arr = date.split(/[\s\.:]+/);
                                var endDate = new Date();
                                endDate.setDate(arr[0]);
                                endDate.setMonth(arr[1] - 1);
                                endDate.setFullYear(arr[2]);
                                endDate.setHours(arr[3]);
                                endDate.setMinutes(arr[4]);
                                endDate.setSeconds(0);
                                return endDate;
                            };
                            var fullKey = this.allKeys[0];//пока выбор всегда на 1 ключе

                            /*Переменная NO_CHECK_DATE находится в static-resources, если static-resources не доступен то проверка даты осуществляется,
                             если static-resources доступен, то определяется переменной NO_CHECK_DATE. Если NO_CHECK_DATE: true - проверка даты нет, false - проверка даты есть*/
                            if (!(typeof EDS_CONFIG != 'undefined' && EDS_CONFIG.NO_CHECK_DATE)) {
                                if (getEndDate(result.notAfter) < (new Date()))
                                    return state.waitingPin.afterCheckPassword(password, {'msg': "expired"});
                            }

                            if (fullKey) {
                                this.keyId = fullKey.split("|")[3];
                                this.key = result.subjectDN;
                                this.dateFrom = result.notBefore;
                                this.dateTo = result.notAfter;
                                this.path = path;
                                this.password = password;
                                this.requirePassword = false;
                                return state.waitingPin.afterCheckPassword(password, true);
                            } else {
                                return state.waitingPin.afterCheckPassword(password, {'msg': 'badCert'});
                            }
                        },
                        access: function (password) {
                            var keyType = $scope.namespace != 'auth' ? "SIGN" : "AUTH";
                            getSignWrapper().getKeys(this.storage, this.path, password, keyType, this);

                        },
                        getKeysCallBack: function (getKeysResult, password) {
                            var r = null;
                            console.log(getKeysResult.getErrorCode());
                            switch (getKeysResult.getErrorCode()) {
                                case "NONE":
                                    this.accessKey(getKeysResult, this.path, password);
                                    return;
                                case "EMPTY_KEY_LIST":
                                    r = {'msg': 'noKeys'};
                                    break;
                                case "WRONG_PASSWORD":
                                    var attemptsCount = getKeysResult.getResult();
                                    if (attemptsCount != null && attemptsCount > -1) {
                                        r = {'msg': 'badPasswordForKaztoken', 'attemptsCount': attemptsCount};//вернет количество оставшихся попыток до блокирования ключа
                                    } else {
                                        r = {'msg': 'badPassword'};
                                    }
                                    break;
                                case "LOAD_KEYSTORE_ERROR":
                                    r = {'msg': 'loadKeystoreError'};
                                    break;
                                default:
                                    r = {'msg': 'badPassword'};
                                    break;
                            }
                            return state.waitingPin.afterCheckPassword(password, r);
                        },
                        signXml: function (xmls) {
                            /*реализация подписания одной xml или массива xml-ок */
                            // getSignWrapper().signXml(this.storage, this.path, this.keyId, this.password, xmls, this);
                            if ($settings.isPod()) {
                                getSignWrapper().signXml(this.storage, this.path, this.keyId, this.password, xmls, this);
                            } else {
                                getSignWrapper().signXmlNew(this.storage, xmls, this);
                            }
                        },
                        signXmlCallBack: function (result) {
                            if(typeof result !== "undefined"){
                                this.sign();
                                result ? callbacks.onSign(result) : false;
                            }
                            reset();
                            getSignWrapper().destroy && getSignWrapper().destroy();
                        }
                    };
                };

                var FileProfile = function () {
                    var file = null;
                    return {
                        type: 'file',
                        validateCookie: function () {
                            if (!cookies.file.exist()) return false;
                            if (/\b\.bin/.test(cookies.file.get().toLocaleLowerCase())) {
                                error('Tumar certificates are not supported');
                                return false;
                            }
                            this.readCookieProfile();
                            this.activate();
                            // state.waitingPin.activate();
                            return true;
                        },
                        readCookieProfile: function () {
                            file = cookies.file.get();
                            this.path = cookies.file.get();
                        },
                        saveCookie: function () {
                            cookies.certType.set('file');
                            cookies.file.set(file);
                        },
                        afterOpen: function (path, callback) {
                            var self = this;
                            file = path;
                            this.path = path;
                            callback();
                        },
                        open: function () {
                            var self = this;
                            if ($settings.isPod() && $scope.namespace != 'auth') {
                                /*Выбор файлового носителя в подах для подписания осуществляется через другой апплет*/
                                runApplet = function () {
                                    if (keyApplet.get()) {
                                        self.activate();
                                        state.chooseFileCon.activate();
                                    } else {
                                        keyApplet.create(function () {
                                            runApplet();
                                        });
                                    }
                                };
                                runApplet();
                            } else {
                                this.activate();
                                getSignWrapper().browseKeyStore(self.storage, "P12", "", this);
                            }
                        },
                        browseKeyStoreCallBack: function (result) {
                            if (result.getErrorCode() === "NONE") {
                                if (result.getResult() != null) {
                                    file = result.getResult();
                                    this.path = result.getResult();
                                    this.activate();
                                    // state.waitingPin.activate();
                                }
                            }
                        }
                    };
                };

                var TokenProfile = function (tokenSlotId, cookieName) {

                    var token = null;

                    return {
                        getTokens: function () {
                            if ($settings.isPod()) {
                                getSignWrapper().loadSlotList(this.storage, this);
                            } else {
                                getSignWrapper().getActiveTokens(this.storage, this);
                            }
                        },
                        loadSlotListCallBack: function (tokens) {
                            var tok = null;
                            if (tokens.getErrorCode() === "NONE") {
                                var lst = tokens.getResult().split("\n");
                                var result = _.filter(lst[0].split("|"), function (token) {//пока реализация для одного слота
                                    return token.length > 0;
                                });
                                tok = result.length == 0 ? null : result;
                            } else {
                                console.log(tokens.getErrorCode());
                            }
                            if (tok && tok.length > 0) {
                                $interval.cancel(state.insertIdcard.interval);
                                $interval.cancel(state.insertKaztoken.interval);
                                // if (this.validatingCookie) {
                                //     if (_.contains(tok, cookies[cookieName].get())) {
                                //         this.readCookieProfile();
                                //         this.activate();
                                //     }
                                //     this.validatingCookie = false;
                                //     state.waitingPin.activate();
                                // } else {
                                this.selectToken(tok[0]);   //пока реализация для одного токена
                                if ($settings.isPod()) {
                                    state.waitingPin.activate();
                                } else {
                                    // }
                                    this.activate();
                                    callbacks.onCert(null);
                                }
                            } else {
                                if (this.validatingCookie) {
                                    this.validatingCookie = false;
                                    clearCookies();
                                    state.chooseCert.activate();
                                }
                            }
                        },
                        getActiveTokensBack: function(result) {
                            console.log('getActiveTokensBack');
                            if (result['code'] === "500") {
                            } else if (result['code'] === "200") {
                                var listOfTokens = result['responseObject'];

                                if (listOfTokens && listOfTokens.length > 0) {
                                    $interval.cancel(state.insertIdcard.interval);
                                    $interval.cancel(state.insertKaztoken.interval);
                                    // if (this.validatingCookie) {
                                    //     if (_.contains(tok, cookies[cookieName].get())) {
                                    //         this.readCookieProfile();
                                    //         this.activate();
                                    //     }
                                    //     this.validatingCookie = false;
                                    //     state.waitingPin.activate();
                                    // } else {
                                    this.selectToken(listOfTokens[0]);   //пока реализация для одного токена
                                    if ($settings.isPod()) {
                                        state.waitingPin.activate();
                                    } else {
                                        // }
                                        if (listOfTokens[0] == 'AKKaztokenStore' && state.insertKaztoken.active() ||
                                            listOfTokens[0] == 'AKKZIDCardStore' && state.insertIdcard.active()) {
                                            this.activate();
                                            callbacks.onCert(null);
                                        }
                                    }
                                } else {
                                    if (this.validatingCookie) {
                                        this.validatingCookie = false;
                                        clearCookies();
                                        state.chooseCert.activate();
                                    }
                                }
                            }
                        },
                        validateCookie: function () {
                            if (!cookies[cookieName].exist()) return false;
                            //return _.contains(this.getTokens(tokenSlotId), cookies[cookieName].get());
                            this.validatingCookie = true;
                            this.getTokens();
                            return false;
                        },
                        readCookieProfile: function () {
                            token = cookies[cookieName].get();
                            this.path = cookies[cookieName].get();
                        },
                        saveCookie: function () {
                            cookies.certType.set(cookieName);
                            cookies[cookieName].set(token);
                        },
                        saveAuthCookie: function () {
                            cookies.authCertType.set(cookieName);
                            cookies[cookieName].set(token);
                        },
                        selectToken: function (activeToken) {
                            token = activeToken;
                            this.path = activeToken;
                            this.activate();
                        }
                    };
                };

                var profile = {
                    file: extend(new BaseProfile("PKCS12"), new FileProfile()),
                    kaztoken: extend(new BaseProfile("AKKaztokenStore"), new TokenProfile(CONST.KAZTOKEN_SLOT, 'kaztoken')),
                    idcard: extend(new BaseProfile("AKKZIDCardStore"), new TokenProfile(CONST.IDCARD_SLOT, 'idcard'))
                };

                return _.extend({
                    loadFromCookie: function () {
                        if (cookies.certType.exist() && _.contains(_.keys(profile), cookies.certType.get())) {
                            profile[cookies.certType.get()].loadFromCookie();
                            return true;
                        }
                        return false;
                    },
                    active: function () {
                        return active;
                    }
                }, profile);
            })();


            var activeState = null;
            var BaseState = function () {
                return {
                    active: function () {
                        return this == activeState;
                    },
                    activate: function () {
                        if (this.active()) {
                            return;
                        }
                        activeState && activeState.onDeactivate();
                        activeState = this;
                        !$scope.$$phase && !$scope.$root.$$phase && $scope.$apply();
                        $scope.activeState = activeState;
                    },
                    onDeactivate: function () {
                    }
                };
            };
            var state = {
                idle: extend(new BaseState(), {
                    activate: function () {
                        this.super.activate();
                        if ($settings.isPep()) $perf.estimate(CONST.APPLET_SIZE);
                    }
                }),
                loading: extend(new BaseState(), {
                    progress: 0,
                    estimate: null,
                    metrics: "s",
                    full: false,
                    certType: null,
                    activate: function () {
                        var _this = this;
                        if (applet.get()) {
                            signWrapper = applet;
                            state.chooseCert.activate();
                            return;
                        }
                        if ($settings.isPep()) {
                            stateCallback = function () {
                                state.chooseCert.activate();
                            };
                            $perf.estimate().then(_.bind(function (result) {
                                var t = Math.floor(result);
                                if (t > 60) {
                                    state.loading.metrics = "m";
                                    t = (t / 60).toFixed(2).split('.');
                                    if (parseInt(t[1]) === 0) {
                                        state.loading.estimate = parseInt(t[0]);
                                    } else {
                                        state.loading.full = true;
                                        state.loading.estimate = [ parseInt(t[0]), parseInt(t[1]) ];
                                    }
                                } else {
                                    state.loading.estimate = t;
                                }
                                this.super.activate();
                                applet.create(function () {
                                    stateCallback && stateCallback()
                                });
                            }, this));
                            this.super.activate();
                            initSocket();
                        } else {
                            state.loading.estimate = 0;
                            this.super.activate();
                            applet.create(function () {
                                state.chooseCert.activate();
                            });
                        }
                        $scope.warningTimer = $timeout(_.bind(function () {
                            $scope.longLoadingWarning = true;
                        }, this), CONST.APPLET_LOADING_TIMEOUT);
                        $scope.cancel = function () {
                            cancel();
                        };
                    },
                    onDeactivate: function () {
                        $timeout.cancel($scope.warningTimer);
                    }
                }),
                chooseCert: extend(new BaseState(), {
                    kaztokens: null,
                    idcards: null,
                    activate: function () {
                        // if (profile.loadFromCookie()) {
                        //     if (cookies.password.exist()) $scope.cookieExists = true;
                        //     //state.waitingPin.activate();
                        // } else {
                        this.select = function (certType) {
                            state[{ idcard: 'insertIdcard', kaztoken: 'insertKaztoken', file: 'chooseFile' }[certType]].activate();
                        };
                        this.super.activate();
                        // }

                        // this.select = function (certType) {
                        //     console.log("chooseCert activate select");
                        //     callbacks.onCert(null);
                        // };

                    }
                }),
                insertIdcard: extend(new BaseState(), {
                    interval: null,
                    activate: function () {
                        this.super.activate();
                        this.interval = $interval(_.bind(function () {
                            profile.idcard.getTokens();
                        }, this), CONST.SLOT_REFRESH_INTERVAL);
                    },
                    onDeactivate: function () {
                        $interval.cancel(this.interval);
                    }
                }),
                insertKaztoken: extend(new BaseState(), {
                    interval: null,
                    activate: function () {
                        this.super.activate();
                        this.interval = $interval(_.bind(function () {
                            profile.kaztoken.getTokens();
                        }, this), CONST.SLOT_REFRESH_INTERVAL);
                    },
                    onDeactivate: function () {
                        $interval.cancel(this.interval);
                    }
                }),
                chooseFile: extend(new BaseState(), {
                    activate: function () {
                        this.super.activate();
                        var _this = this;
                        profile.file.open();
                    }
                }),
                chooseFileCon: extend(new BaseState(), {
                    path: [],
                    dirs: null,
                    files: null,
                    activate: function () {
                        state.chooseFileCon.dirs = null;
                        state.chooseFileCon.files = null;
                        state.chooseFileCon.path = [];
                        this.getFilesDirs = function () {
                            state.chooseFileCon.dirs = keyApplet.get().getAllDirs(state.chooseFileCon.path);
                            state.chooseFileCon.files = keyApplet.get().getAllFiles(state.chooseFileCon.path);
                        };
                        this.onClickDir = function (dir) {
                            state.chooseFileCon.path.push(dir.toString());
                            this.getFilesDirs();
                        };
                        this.onClickFile = function (file) {
                            var keyPath = keyApplet.get().getFilePath(state.chooseFileCon.path, file);
                            profile.active().afterOpen(keyPath, function () {
                                state.waitingPin.activate();
                            });
                        };
                        this.onClickUp = function () {
                            state.chooseFileCon.path = _.without(state.chooseFileCon.path, state.chooseFileCon.path[state.chooseFileCon.path.length - 1]);
                            this.getFilesDirs();
                        };
                        this.getFilesDirs();
                        this.super.activate();
                    }
                }),
                waitingPin: extend(new BaseState(), {
                    msg: {},
                    activate: function (signCallback) {
                        this.afterCheckPassword = function (password, checkResult) {
                            if (checkResult === true) {
                                if ($cookie.get('role') == 'operator' && $settings.isPod()) {
                                    cookies.password.set(password);
                                }
                                if (signCallback) {
                                    signCallback();
                                } else {
                                    this.nextState();
                                }
                            } else {
                                this.checkResultFalse(checkResult);
                            }
                            $scope.$apply();
                        };
                        if (cookies.password.exist()) {
                            this.checkResultFalse = function (checkResult) {
                                clearCookies();
                                state.chooseCert.activate();
                            };
                            this.nextState = function () {
                                state.viewingCertInfo.activate();
                                state.viewingCertInfo.sign();
                            };
                            var pwd = cookies.password.get();
                            if (!!profile.active()) {
                                profile.active().access(pwd);
                            } else {
                                this.checkResultFalse(null);
                            }
                        } else {
                            state.waitingPin.pinValue = "";
                            if ($injector.get('$settings').isEnabled()) {
                                state.waitingPin.pinValue = "123456";
                            }
                            state.waitingPin.msg = {};
                            this.super.activate();
                            this.onPinEnter = _.bind(function (value) {
                                state.waitingPin.pinValue = "";
                                if ($injector.get('$settings').isEnabled()) {
                                    state.waitingPin.pinValue = "123456";
                                }
                                state.waitingPin.msg = {};
                                profile.active().access(value);
                            }, this);
                            this.checkResultFalse = function (checkResult) {
                                this.msg[checkResult.msg] = true;
                                this.msg.attemptsCount = checkResult.attemptsCount;
                            };
                            this.nextState = function () {
                                state.viewingCertInfo.activate();
                            };
                            this.onPinCancel = _.bind(function () {
                                clearCookies();
                                state.chooseCert.activate();
                            }, this);

                            webkitForceRender();
                        }
                    }
                }),
                viewingCertInfo: extend(new BaseState(), {
                    certInfo: {},
                    errors: [],
                    activate: function () {
                        state.viewingCertInfo.errors = [];
                        this.certInfo = profile.active().parse();
                        this.changeCert = function () {
                            clearCookies();
                            state.chooseCert.activate();
                        };
                        var executeSign = function () {
                            state.viewingCertInfo.errors = [];
                            if (state.viewingCertInfo.certInfo.isIin && !_.contains(filter, 'fl')) {
                                state.viewingCertInfo.errors.push('cert.flCertNotAllowed');
                            }
                            if (!state.viewingCertInfo.certInfo.isIin && !_.contains(filter, 'ul')) {
                                state.viewingCertInfo.errors.push('cert.ulCertNotAllowed');
                            }
                            if (allowedUin && state.viewingCertInfo.certInfo.uin != allowedUin) {
                                state.viewingCertInfo.errors.push('cert.uinMismatch');
                            }
                            if (state.viewingCertInfo.errors.length != 0) {
                                return;
                            }

                            callbacks.onCert(state.viewingCertInfo.certInfo);
                        };
                        this.sign = function () {
                            if (profile.requirePassword) {
                                state.waitingPin.activate(executeSign());
                            } else {
                                executeSign();
                            }

                        };
                        this.super.activate();
                    }
                })
            };
            _.each(_.keys(state), function (key) {
                state[key].id = key;
            });
            state.idle.activate();

            $scope.state = state;
            $scope.cookieExists = false;

            var filter = [ 'ul', 'fl' ];
            var callbacks;
            var apply = function (xmlToSign) {
                profile.active().signXml(xmlToSign);
            };

            function cancel() {
                reset();
                callbacks.onCancel();
            }

            function reset() {
                if ($scope.state.loading.active()) {
                    applet.destroy();
                }
                $scope.state.idle.activate();
            }

            $scope.cancel = cancel;

            var testCert = {
                pathToFileCert: null,
                password: null
            };
            var allowedUin = null;

            function addTestFileCert(pathToFileCert, password) {
                testCert.pathToFileCert = pathToFileCert;
                testCert.password = password;
            }

            return {
                open: _.bind(function (options) {
                    filter = options.filter || filter;
                    callbacks = options;
                    callbacks.onSign = callbacks.onSign || function () {
                    };
                    callbacks.onCert = callbacks.onCert || function () {
                    };
                    callbacks.onCancel = callbacks.onCancel || function () {
                    };
                    callbacks.onError = callbacks.onError || function () {
                    };
                    if ($scope.state.idle.active()) {
                        $scope.state.loading.activate();
                    }
                }, this),

                apply: apply,

                reset: function () {
                    reset();
                },

                namespace: namespace.value,

                getCertInfo: function () {
                    return state.viewingCertInfo.certInfo;
                },

                enableStorage: function (uin) {
                    if ($cookie.get('uin') != uin) clearCookies();
                    storageUin = uin;
                },

                resetStorage: function () {
                    storageUin = null;
                    clearCookies();
                },

                setAllowedUin: function (_allowedUin) {
                    allowedUin = _allowedUin;
                },

                addTestFileCert: addTestFileCert
            };

        }


        return this;
    }]);
