angular.module("app").directive('flselect', ['$uin', '$dictionary', '$declaration', '$locales', '$rootScope', '$robot', '$error',
    function ($uin, $dictionary, $declaration, $locales, $rootScope, $robot, $error) {
        return {
            scope: {
                uin: '=iin',
                ngTitle: '@',
                title: '@'
            },

            replace: true,
            restrict: 'E',
            transclude: true,
            templateUrl: "kit/directives/flselect/flselect.html",
            controller: function ($scope) {
                $scope.getValidationMessage = function () {
                    var error = _.find(_.keys($scope.viewModel.errors), function (key) {
                        return $scope.viewModel.errors[key];
                    });
                    var warning = _.find(_.keys($scope.viewModel.warnings), function (key) {
                        return $scope.viewModel.warnings[key];
                    });
                    return error && ('iinSelect.error.' + error) || warning && ('iinSelect.warning.' + warning);
                }
            },
            link: function (scope, element, attrs, model) {

                if (!$uin.isIin(scope.uin)) {
                    scope.uin = "";
                }

                function reset() {
                    scope.viewModel = {
                        errors: {
                            isEmpty: false,
                            isInvalid: false,
                            isUnknown: false,
                            badStatus: false,
                            noConnection: false
                        },
                        haveErrors: false,

                        warnings: {
                            lengthWarning: false
                        },
                        haveWarnings: false,

                        validationMessageMinified: false,

                        uinFocus: false,
                        info: null,

                        remoteCheckFinished: false,
                        remoteCheckError: false,

                        inputModel: scope.uin
                    };
                }

                reset();

                scope.$watch("uin", function (val) {
                    val = String(val);
                    if (scope.viewModel.inputModel != val) {
                        reset();
                        scope.viewModel.inputModel = val;
                        var clearDirty = _.isEmpty(val) && !scope.inputController.$dirty;
                        scope.inputController && scope.inputController.$setViewValue(val);
                        scope.inputController && scope.inputController.$render();
                        if( clearDirty ) scope.inputController.$setPristine();
                        scope.onChange(val);
                    }
                });


                scope.$watch("viewModel.inputModel", function (val) {
                    scope.onChange(val);
                });

                scope.onChange = function (val) {
                    var model = scope.viewModel;
                    model.remoteCheckFinished = false;
                    model.remoteCheckError = false;
                    model.info = null;
                    if (validate(val)) {

                        $uin.getIndividualShortInfo(val)
                            .success(function (data) {
                                model.remoteCheckFinished = true;
                                model.info = data;
                                if (validate(val)) {
                                    scope.uin = val;
                                }
                            })
                            .error(function (data, status) {
                                model.remoteCheckFinished = true;
                                if (status == '404') {
                                    $robot.wonder();
                                } else {
                                    model.remoteCheckError = true;
                                    $error.setError("iinSelect.error.noConnection");
                                    $robot.connectionError();
                                }
                                validate(val);
                            })
                    }
                };

                scope.reconnect = function () {
                    var model = scope.viewModel;
                    scope.onChange(scope.inputController.$viewValue);
                };

                function validate(uin) {
                    var model = scope.viewModel,
                        errors = scope.viewModel.errors,
                        warnings = scope.viewModel.warnings;

                    var isDirty = scope.inputController && scope.inputController.$dirty;

                    errors.isEmpty = isDirty && _.isEmpty(uin);

                    var isFullLength = uin.length == 12;

                    errors.isInvalid = isDirty && !errors.isEmpty && isFullLength && !$uin.isIin(uin);
                    errors.noConnection = isDirty && !errors.isInvalid && model.remoteCheckFinished && model.remoteCheckError;
                    errors.isUnknown = isDirty && !errors.noConnection && model.remoteCheckFinished && !model.info;
                    errors.badStatus = isDirty && !errors.isUnknown && model.remoteCheckFinished && _.contains(['MISSING', 'ABSENT', 'DISAPPEARED', 'EXCLUDED', 'REMOVED'], model.info.status);

                    model.haveErrors = _.contains(_.values(errors), true);

                    warnings.lengthWarning = isDirty && uin && uin.length > 7 && uin.length < 12;
                    model.haveWarnings = _.contains(_.values(warnings), true);

                    return !model.haveErrors && !model.haveWarnings && isFullLength;
                }
            }

        }
    }]);
